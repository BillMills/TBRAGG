<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 TRANSITIONAL//EN">
<html>
	<head>
		<title>HMTF TBragg</title>
		<!-- include the mhttpd JS library -->
		<script src="mhttpd.js" type="text/javascript"></script>

		<script type="text/javascript">
			var my_action = '"/CS/try&"'
			var ival;
			var my_expt="midas";
		</script>

		<style type="text/css">
			* { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }

			.t1{clear:both; width:25%; float:left; text-align:right; margin:0px 0px 0px 0px;}
			.t2{width:70%; float:left; text-align:left; margin:0px 0px 0px 0px;}
			.c1{height:30px;  margin:0px 53px 0px 0px;}
			.c1t{height:30px; margin:3px 5px 0px 0px;}
			.c2{height:30px; margin:0px 0px 0px 0px;}
			.buff{clear:both; width:100%; height:15px;}
			.limitBox{width:130px}
			td{padding:0px;}
			button.navLink{
				background: #4C4C4C; 
				color: #FFFFFF;
				border-color: #333333; 
				border-radius: 5px;
			    display: inline;
			    font-family: 'Raleway', sans-serif;
			    font-size:14px;
			}

			table.mainElement{
				border:5px solid; 
				border-radius:25px; 
				padding:10px;
			}

			div.section{
				border:5px solid; 
				border-radius:25px; 
				padding:10px;
			}

			body.standard{
				background:#333333; 
				color:#999999; 
				font-family: "Raleway", sans-serif;				
			}

			:invalid{
				color: #FF0000;
			}

			caption{
				font: 20px Raleway;
			}

		</style>
	</head>

	<body id='body' class='standard'>

		<div id='loading' style='width:100px; height:100px; border:5px solid; border-color:#FFFFFF; border-radius:25px; background:#000000; text-align:center; margin-left:auto; margin-right:auto; position:relative; top:300px'><p style='position:relative; top:50px; font:16px Arial'>Loading<p></div>

	    <script type="text/javascript">

			function main(){

				//scale subtables to match
				//document.getElementById('el1').setAttribute('style', 'width:auto; height:'+document.getElementById('masterTable').offsetHeight)				
				//document.getElementById('el2').setAttribute('style', 'width:auto; height:'+document.getElementById('masterTable').offsetHeight)

				//put nice charcodes in the scroll buttons:
				document.getElementById('bigLeft2D').innerHTML = String.fromCharCode(0x21C7);
				document.getElementById('bigRight2D').innerHTML = String.fromCharCode(0x21C9);
				document.getElementById('smallLeft2D').innerHTML = String.fromCharCode(0x2190);
				document.getElementById('smallRight2D').innerHTML = String.fromCharCode(0x2192);
				document.getElementById('bigUp').innerHTML = String.fromCharCode(0x21C8);
				document.getElementById('bigDown').innerHTML = String.fromCharCode(0x21CA);
				document.getElementById('smallUp').innerHTML = String.fromCharCode(0x2191);
				document.getElementById('smallDown').innerHTML = String.fromCharCode(0x2193);

				//TBRAGG namespace
				TBparam = {
					'svgns' : 'http://www.w3.org/2000/svg',
					'historyURL' : 'http://midtig04.triumf.ca:8082/HS/',
					'num_gates' : 0,
					'old_num_gates' : 0,
					'GateMax' : [10000,5000,5000,5000,5000],
					'ResetTime' : 0,
					'x' : 0,
					'obj' : 0,
					'i' : 0,
					'img' : 0,
					'name' : 0,
					'cmd' : 0,
					'oldLevels' : [0,0,0,0,0],
					'levels' : [0,0,0,0,0],
					'rate' : [0,0,0,0,0],
					'int' : [0,0,0,0,0],
					'barChartColors' : ['#0000FF', '#FF0000', '#00FFFF', '#E68A2E', '#FF00FF'],
					'runTimer' : 1000  //0=run stop, 1->300 = seconds left in 5min countdown, 1000 = perpetual mode
				};
				TBparam.num_gates = parseInt(ODBAGet("/Analyzer/Parameters/Gate0/NGates"));
				TBparam.ResetTime = ODBAGet("/Analyzer/Parameters/Gate0/ResetTime");

				//Spectrum viewer namespace (a lot of these could be dropped, don't need the 1D functionality here)
				SVparam = {
					"devMode" : 1,
					"refreshHandler" : 0,
					'activeCursor' : 0,
					"statusURL" : 'http://midtig04.triumf.ca:8082',
					"hostname" : "localhost:9092",
					"RefreshTime" : 3,
					"XaxisLimitMin" : 0,
					"XaxisLimitMax" : 500,
					"XaxisLimitAbsMax" : 512,
					"XaxisLength" : 0,
					"YaxisLimitMin" : 0,
					"YaxisLimitMax" : 204,
					"YaxisLength" : 0,
					"maxYvalue" : 200,
					"dataColor" : ["#FFFFFF", "#FF0000", "#00FFFF", "#00FF00", "#FF9900", "#0000FF", "#FFFF00", "#FF00CC", "#00CC00", "#990099"],
					"XMouseLimitxMin" : 0,
					"XMouseLimitxMax" : 0,
					"DataType" : 0,
					"AxisType" : 0,
					"Specs" : [],
					"DisplayedSpecs" : [],
					"spectrum_names" : [],
					"NumSpecsDisplayed" : 0,
					"Fitted" : 0,
					"FitLimitLower" : -1,
					"FitLimitUpper" : -1,
					"word" : 'Hello there',
					"data" : [],
					"KnownHostnames" : ["midtig03:9095", "localhost:9092"],
					"refreshMap" : [0,1,2,5,10],
					"totalEntries" : 0,

					"canvasID" : 'testCanv',			//id of canvas to draw spectra in
					"canvas" : 0,
					"context" : 0,
					'canvWidth' : 960,					//spectrum canvas width
					'canvHeight' : 420,					//  "" height
					"leftMargin" : 100,					//left gutter of plot area
					"bottomMargin" : 50, 				//bottom gutter of plot area
					"rightMargin" : 100,				//right gutter of plot area
					"topMargin" : 20, 					//top gutter of plot area
					"xAxisPixLength" : 0,				//in pixels
					"yAxisPixLength" : 0,				//in pixels
					"tickLength" : 5, 					//axis tickmark length
					"nXticks" : 6,						//number of ticks on the x axis
					"nYticks" : 5,						//number of ticks on the y axis
					"xLabelOffset" : 5, 				//x axis labels sit this far below the bottom of their tick
					"yLabelOffset" : 5, 				//y axis labels sit this many pix to the left of their tick
					"binWidth" : 0, 					//width of histo bin in pixels
					"countHeight" : 0, 					//height in pix accrued by a bin for each count
					"baseFont" : '18px Arial',			//default font
					"expFont" : '14px Arial',			//exponent font
					"clickBounds" : [],					//bounds clicked by the user
					"fitModeEngage" : 0, 				//determines if the event listeners on the canvas initiate zoom (0) or fit (1) procedures
					"dataBuffer" : [],					//buffer data so we don't re-fetch it.

					'refreshHandler2D' : 0,
					'meterRefreshHandler2D' : 0,
					'canvasID2D' : 'canvas2D',
					'canvas2D' : 0,
					'context2D' : 0,
					'canvWidth2D' : 0,
					'canvHeight2D' : 0,
					'binWidth2D' : 0,
					'binHeight2D' : 0,
					'XaxisLimitMin2D' : 0,
					'XaxisLimitMax2D' : 500,
					'XaxisLimitAbsMax2D' : 500,
					'YaxisLimitMin2D' : 0,
					'YaxisLimitMax2D' : 500,
					'YaxisLimitAbsMax2D' : 500,
					'xAxisPixLength2D' : 0,
					'yAxisPixLength2D' : 0,
					"leftMargin2D" : 100,					//left gutter of plot area
					"bottomMargin2D" : 70, 				//bottom gutter of plot area
					"rightMargin2D" : 20,				//right gutter of plot area
					"topMargin2D" : 50, 					//top gutter of plot area
					'XaxisLength2D' : 0,
					'YaxisLength2D' : 0,
					'onclickXvals' : {'min':-1, 'max':-1},
					'onclickYvals' : {'min':-1, 'max':-1},
					'clickX' : {'down':-1, 'up':-1},
					'clickY' : {'down':-1, 'up':-1},
					'zMax' : .001,
					'logZ' : 1,			//turn on log scale for z in 2d plots
					'logZmin' : -1,
					'zScaleMargin' : 200
				};

				//2D canvas:
				SVparam.canvWidth2D = document.getElementById('spectrumDisplay').offsetWidth*0.9; //window.innerWidth*0.4 + SVparam.zScaleMargin;
				SVparam.canvHeight2D = document.getElementById('spectrumDisplay').offsetHeight*0.85; //window.innerWidth*0.4;
				SVparam.canvas2D = document.getElementById('canvas2D');
				SVparam.context2D = SVparam.canvas2D.getContext('2d');
				SVparam.canvas2D.setAttribute('width', SVparam.canvWidth2D);
				SVparam.canvas2D.setAttribute('height', SVparam.canvHeight2D);
				SVparam.xAxisPixLength2D = SVparam.canvas2D.width - SVparam.leftMargin2D - SVparam.rightMargin2D - SVparam.zScaleMargin;
				SVparam.yAxisPixLength2D = SVparam.canvas2D.height - SVparam.topMargin2D - SVparam.bottomMargin2D;
				SVparam.XaxisLength2D = SVparam.XaxisLimitMax2D-SVparam.XaxisLimitMin2D;
				SVparam.YaxisLength2D = SVparam.YaxisLimitMax2D-SVparam.YaxisLimitMin2D;
				SVparam.context2D.font = SVparam.baseFont;
				//SVparam.context2D.shadowBlur = 1;
				//fake data for now:
				var i,j;

				//style barchart canvas:
	    		document.getElementById('rateBars').setAttribute('width', document.getElementById('gateRatesDisplay').offsetWidth*0.90);
	    		document.getElementById('rateBars').setAttribute('height', document.getElementById('gateRatesDisplay').offsetHeight*0.80);

				//check the appropriate gate radio:
				TBparam.x="g"+TBparam.num_gates;
				document.getElementById(TBparam.x).checked=true;

	        	//plug in MIDAS status page link:
    		    document.getElementById('statusB').setAttribute('onclick', "window.location='"+SVparam.statusURL+"';");

	        	//plug in history page link:
    		    document.getElementById('historyB').setAttribute('onclick', "window.location='"+TBparam.historyURL+"';");

				//generate the gate interface:
				document.getElementById('Gate_params').innerHTML = '';
				for(TBparam.i=0; TBparam.i<TBparam.num_gates; TBparam.i++){
					document.getElementById('Gate_params').innerHTML += "<br><b>Gate"+(TBparam.i+1)+":</b> Centre of box (x,y): ";
					document.getElementById('Gate_params').innerHTML += "<input type='text' id='Gatex"+TBparam.i+"' style='width:40px'; onchange='setGateX(this)'>,";
					document.getElementById('Gate_params').innerHTML += "<input type='text' id='Gatey"+TBparam.i+"' style='width:40px'; onchange='setGateY(this)'>";
					document.getElementById('Gate_params').innerHTML += "Size: <input type='text' id='GateSize"+TBparam.i+"' style='width:40px'; onchange='setGateSize(this)'><br>";
				}

				//refresh some things and pull some stuff out of the ODB
				mod_layout();
				refreshAll();
				for(TBparam.i=0; TBparam.i<=TBparam.num_gates; TBparam.i++){
					TBparam.name="Gatex"+TBparam.i;
					TBparam.cmd="/Analyzer/Parameters/Gate"+TBparam.i+"/x";
					document.getElementById(TBparam.name).value=ODBAGet(TBparam.cmd);
					TBparam.name="Gatey"+TBparam.i;
					TBparam.cmd="/Analyzer/Parameters/Gate"+TBparam.i+"/y";
					document.getElementById(TBparam.name).value=ODBAGet(TBparam.cmd);
					TBparam.name="GateSize"+TBparam.i;
					TBparam.cmd="/Analyzer/Parameters/Gate"+TBparam.i+"/size";
					document.getElementById(TBparam.name).value=ODBAGet(TBparam.cmd);
				}

          		//establish event listeners on 2D spectra:
				document.getElementById(SVparam.canvasID2D).onmousedown = function(event){mDown2D(event)};
				document.getElementById(SVparam.canvasID2D).onmouseup = function(event){mUp2D(event)};
				SVparam.canvas2D.addEventListener('mousemove', function(event){mMove2D(event)}, false);
				document.getElementById(SVparam.canvasID2D).onmouseout = function(event){document.getElementById('2Dcoords').innerHTML=''};

				//set the refresh rate
				document.getElementById("refreshRate2D").value = SVparam.RefreshTime;

				//scale head table nicely:
				//document.getElementById('headTable').setAttribute('style', 'text-align:center; margin-left:auto; margin-right:auto; width:'+document.getElementById('masterTable').offsetWidth)
				//document.getElementById('branding').setAttribute('style', 'height:85; border-color:#999999; border-left-style:solid; border-bottom-style:solid; border-left-width:5px; border-bottom-width:5px; border-bottom-left-radius:25px; background-color:#333333; margin-bottom:5px; width:'+Math.max(document.getElementById('masterTable').offsetWidth, window.innerWidth)  )

				plot_data2D(1, 'true');

				//kill the spinner and let the page appear
				document.getElementById('mainBody').setAttribute('style', 'opacity:1');
				var spinElt = document.getElementById('loading');
          		spinElt.parentNode.removeChild(spinElt);

			}

	      //load the webfonts, and block the page until they're ready or failed - otherwise lots of rendering bugs happen!
	      WebFontConfig = { google: { families: [ 'Orbitron', 'Raleway' ] },
	        loading: function(){

	        },
	        active: function() {
	          main();
	        },
	        inactive: function() {
	          main();
	        }
	      };
	      //thx paul:
	      (function() {
	        var wf = document.createElement('script');
	        wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
	            '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
	        wf.type = 'text/javascript';
	        wf.async = 'true';
	        var s = document.getElementsByTagName('script')[0];
	        s.parentNode.insertBefore(wf, s);
	      })();
	    </script>

	    <div id='mainBody' style='opacity:0'>

			<div id='branding' style='width:100%; height:85; border-color:#999999; border-left-style:solid; border-bottom-style:solid; border-left-width:5px; border-bottom-width:5px; border-bottom-left-radius:25px; background-color:#333333; margin-bottom:5px;'>
				<!--img id='logo' height='80px' width='80px' src='triumf.gif' style='opacity:0.5625; padding-left:10px;'></img-->
				<h1 id='title' style='position:relative; display:inline; font: 80px Raleway; top:-10px; margin-left:20px;'>TRIUMF</h1>
			</div>

			<div id='navbar' style='width: 100%; margin-bottom:10px;'>
				<button id='startB' class='navLink' name="cmd" value="Start" type="submit" onclick="setResetTime(); TBparam.runTimer=1000; document.getElementById('refreshRate2D').value=3; document.getElementById('refreshRate2D').onchange();">Start Perpetual Run</button>
				<button id='statusB' class='navLink' name="cmd" value="Status" type="submit">MIDAS Status</button>
				<button id='historyB' class='navLink' name="cmd" value="History" type="submit">History</button>
				<!--input type=hidden name="redir" value="/CS/Monitor"-->
				<button id='run5B' class='navLink' type=submit name=customscript value="Start 5 Min Run" onclick="setResetTime(); TBparam.runTimer=300;">Start 5 Min Run</button>
				<h2 id='youAreHere' style='position:absolute; display:inline; margin:0px; right:20px;'>TBRAGG Monitor</h2>
			</div>

			<h2 style='margin-bottom:0px; margin-left:auto; margin-right:auto; text-align:center;'>Run Status & Gate Control</h2>
			<div id='runControl' class='section' style='width:100%; height:auto; text-align:center; padding-top:15px; margin-bottom:10px;'>
				<div id="run_status" align='center' style='color:#000000; width:12%; display:inline; padding:10px;'></div>
				<div id="run_num" style='width:12%; display:inline; margin-left:2%;'></div>
				<div id='dateLine' style='width:12%; display:inline; margin-left:2%;'></div>
				<div style='width:12%; text-align:right; display:inline; margin-left:2%;'>
					Refresh Rate: 
					<select id="refreshRate2D" onchange="SVparam.RefreshTime=this.value; window.clearTimeout(SVparam.refreshHandler2D); plot_data2D(1, 'true'); window.clearTimeout(SVparam.meterRefreshHandler2D); refreshAll()">
						<option id="r0" value="0">Off</option>
						<option id="r1" value="1">1s</option>
						<option id="r2" value="3">3s</option>
						<option id="r3" value="5">5s</option>
						<option id="r4" value="10">10s</option>
					</select>
				</div>

				<div id='nGatesToggle' style='padding-top:0.5%;'>
					Number of Gates: 1<input type="radio" id="g0" value="0" onclick="set_radios(this)"> 
					2<input type="radio" id="g1" value="1" onclick="set_radios(this)"> 
					3<input type="radio" id="g2" value="2" onclick="set_radios(this)"> 
					4<input type="radio" id="g3" value="3" onclick="set_radios(this)"> 
				</div>

				<div id='Gate_params' style='padding-top:0.5%;'></div>
			</div>


			<h2 style='display:inline; text-align:center; width:60%; float:left; margin-bottom:0px'>Spectrum Control</h2>
			<h2 style='display:inline; text-align:center; width:38%; float:right; margin-bottom:0px'>Gate Rates</h2>
			<div id='spectrumDisplay' class='section' style='width:60%; height:80%; float:left;'>
				<div id='spectrumWrapper' style='width:100%; height:90%; position:relative;'>
					<form style='width:5%; position:absolute; left:0%; bottom:70px; text-align:right;'>
						<button id='bigUp' class='navLink' type="button" value=">>" onclick="scrollSpectra(SVparam.YaxisLimitMax2D - SVparam.YaxisLimitMin2D, 'YaxisLimitMin2D', 'YaxisLimitMax2D', 'YaxisLimitAbsMax2D', 'LowerYLimit', 'UpperYLimit'); plot_data2D(0)">U</button><br>
						<button id='smallUp' class='navLink' type="button" value=">" onclick="scrollSpectra(1, 'YaxisLimitMin2D', 'YaxisLimitMax2D', 'YaxisLimitAbsMax2D', 'LowerYLimit', 'UpperYLimit'); plot_data2D(0)">u</button><br>
						<button id='smallDown' class='navLink' type="button" value="<" onclick="scrollSpectra(-1, 'YaxisLimitMin2D', 'YaxisLimitMax2D', 'YaxisLimitAbsMax2D', 'LowerYLimit', 'UpperYLimit'); plot_data2D(0)">d</button><br>
						<button id='bigDown' class='navLink' type="button" value="<<" onclick="scrollSpectra(SVparam.YaxisLimitMin2D - SVparam.YaxisLimitMax2D, 'YaxisLimitMin2D', 'YaxisLimitMax2D', 'YaxisLimitAbsMax2D', 'LowerYLimit', 'UpperYLimit'); plot_data2D(0)">D</button><br>
						y axis limits:<br>
						<input type="number" id="UpperYLimit" style="width:60px;" onchange="setAxisLimit(parseInt(this.value), this.id, 'YaxisLimitMax2D', 'YaxisLimitAbsMax2D');plot_data2D(0); document.getElementById('LowerYLimit').setAttribute('max', this.value);" min='0' max='500'></input><br>
						<input type="number" id="LowerYLimit" style="width:60px;" onchange="setAxisLimit(parseInt(this.value), this.id, 'YaxisLimitMin2D', 'YaxisLimitAbsMax2D');plot_data2D(0); document.getElementById('UpperYLimit').setAttribute('min', this.value);" min='0' max='500'></input>  
						
						<div id="limitMistake" style="color:'#00FFFF'"></div>
					</form>
					<canvas id='canvas2D' style='position:absolute; left:5%; bottom:0%' ></canvas>
				</div>

				<form style='margin-left:100px; display:inline;'>
					x axis limits:
					<input type="number" id="LowerXLimit2D" style="width:60px;" onchange="setAxisLimit(parseInt(this.value), this.id, 'XaxisLimitMin2D', 'XaxisLimitAbsMax2D');plot_data2D(0); document.getElementById('UpperXLimit2D').setAttribute('min', this.value);" min='0' max='500'></button>
					<input type="number" id="UpperXLimit2D" style="width:60px;" onchange="setAxisLimit(parseInt(this.value), this.id, 'XaxisLimitMax2D', 'XaxisLimitAbsMax2D');plot_data2D(0); document.getElementById('LowerXLimit2D').setAttribute('max', this.value);" min='0' max='500'></button>
					<button id='bigLeft2D' class='navLink' type="button" value="<<" onclick="scrollSpectra(SVparam.XaxisLimitMin2D - SVparam.XaxisLimitMax2D, 'XaxisLimitMin2D', 'XaxisLimitMax2D', 'XaxisLimitAbsMax2D', 'LowerXLimit2D', 'UpperXLimit2D'); plot_data2D(0)"><<</button>
					<button id='smallLeft2D' class='navLink' type="button" value="<" onclick="scrollSpectra(-1, 'XaxisLimitMin2D', 'XaxisLimitMax2D', 'XaxisLimitAbsMax2D', 'LowerXLimit2D', 'UpperXLimit2D'); plot_data2D(0)"><</button>
					<button id='smallRight2D' class='navLink' type="button" value=">" onclick="scrollSpectra(1, 'XaxisLimitMin2D', 'XaxisLimitMax2D', 'XaxisLimitAbsMax2D', 'LowerXLimit2D', 'UpperXLimit2D'); plot_data2D(0)">></button>
					<button id='bigRight2D' class='navLink' type="button" value=">>" onclick="scrollSpectra(SVparam.XaxisLimitMax2D - SVparam.XaxisLimitMin2D, 'XaxisLimitMin2D', 'XaxisLimitMax2D', 'XaxisLimitAbsMax2D', 'LowerXLimit2D', 'UpperXLimit2D'); plot_data2D(0)">>></button>
					<div id="limitMistake2D" style="color:'#00FFFF'"></div>
				</form>

				<p id="2Dcoords" style='float:right; margin:0px; margin-right:100px'></p>

				<form style='margin-left:100px'>
					<button id='saveASCIIB' class='navLink' type="button" value="Save ASCII" onclick="dump2D()">Save ASCII</button>	
					<button id='unzoom2D' class='navLink' type="button" value="Unzoom" onclick="Unzoom();">Unzoom</button>
				</form>
			</div>

			<div id='gateRatesDisplay' class='section'; style='width:38%; height:80%; float:right; text-align:center;'>
				<h4 style='display:inline; width:8%'>Max[Hz]</h4>
				<input type="text" id="MaxT" style="width:9%; display:inline;" onchange="TBparam.GateMax[0]=this.value;"></input>
				<input type="text" id="MaxG" style="width:9%; display:inline; margin-left:7.2%;" onchange="TBparam.GateMax[1]=this.value;"></input>
				<input type="text" id="MaxG1" style="width:9%; display:inline; margin-left:7.2%;" onchange="TBparam.GateMax[2]=parseInt(this.value);"></input>
				<input type="text" id="MaxG2" style="width:9%; display:inline; margin-left:7.2%;" onchange="TBparam.GateMax[3]=parseInt(this.value);"></input>
				<input type="text" id="MaxG3" style="width:9%; display:inline; margin-left:7.2%;" onchange="TBparam.GateMax[4]=parseInt(this.value);"></input>

				<div id='rateBarCell'>
					<canvas id='rateBars'> </canvas>
				</div>

				<div style='margin-top:10px;'>
					<p id="Time_display" style='display:inline;'></p> seconds since last reset
				</div>
							
			</div>

		</div>

		<script type="text/javascript">
function set_radios(word){
	var x;

	x=word.id;
	x=x.substring(0,1)+"0"; document.getElementById(x+"").checked=false;
	x=x.substring(0,1)+"1"; document.getElementById(x+"").checked=false;
	x=x.substring(0,1)+"2"; document.getElementById(x+"").checked=false;
	x=x.substring(0,1)+"3"; document.getElementById(x+"").checked=false;
	x=word.id; document.getElementById(x+"").checked=true;
	TBparam.old_num_gates=TBparam.num_gates;
	TBparam.num_gates=parseInt(x.substring(1,2));
	ODBASet("/Analyzer/Parameters/Gate0/NGates",TBparam.num_gates);
	mod_layout();
}

function RemoveScaler(Num){
	var img;

	if(Num<2 || Num>4) return;

	img = document.getElementById("svgimage");
	img.removeChild(img.getElementById("ScalerGroup"+Num));
	img.getElementById('Scaler'+Num).setAttribute("height", 0);
	img.getElementById('ScalerNum'+Num).textContent="";
	img.getElementById('ScalerTot'+Num).textContent="";
}

function mod_layout(){

	// Set initial values
	document.getElementById("MaxT").value=TBparam.GateMax[0];
	document.getElementById("MaxG").value=TBparam.GateMax[1];
	if(TBparam.num_gates>0){
		document.getElementById("MaxG1").value=TBparam.GateMax[2];
		document.getElementById("MaxG1").style.opacity = 1;
	} else
		document.getElementById("MaxG1").style.opacity = 0;
	if(TBparam.num_gates>1){
		document.getElementById("MaxG2").value=TBparam.GateMax[3];
		document.getElementById("MaxG2").style.opacity=1;
	} else
		document.getElementById("MaxG2").style.opacity = 0;
	if(TBparam.num_gates>2){
		document.getElementById("MaxG3").value=TBparam.GateMax[4];
		document.getElementById("MaxG3").style.opacity=1;
	} else
		document.getElementById("MaxG3").style.opacity = 0;
	mod_gate_params();
}

//TODO: move the DOM element definitions to HTML, and make this function hide / show as appropriate
function mod_gate_params(){
	var font=TBparam.barChartColors.slice(1,6), //["#FF0000", "#00FF00", "#FFFF00", "#FF00FF"],
		obj=document.getElementById("Gate_params"),
		line="",
		i, name, cmd;

	for(i=0; i<=TBparam.num_gates; i++){
		line=line+"<font style=\"color: "+font[i]+";\"><b>Gate"+(i+1)+":</b></font> Centre (x,y): <input type=\"text\" id=\"Gatex"+i+"\" style=\"width:40px\"; onchange=\"setGateX(this); plot_data2D(1, 'true')\">,<input type=\"text\" id=\"Gatey"+i+"\" style=\"width:40px\"; onchange=\"setGateY(this); plot_data2D(1, 'true')\">Size: <input type=\"text\" id=\"GateSize"+i+"\" style=\"width:40px; margin-right:20px;\"; onchange=\"setGateSize(this); plot_data2D(1, 'true')\">";

	}
	obj.innerHTML=line;
	drawTbraggGates();

	for(i=0; i<=TBparam.num_gates; i++){
		name="Gatex"+i;
		cmd="/Analyzer/Parameters/Gate"+i+"/x";
		document.getElementById(name).value=ODBAGet(cmd);
		name="Gatey"+i;
		cmd="/Analyzer/Parameters/Gate"+i+"/y";
		document.getElementById(name).value=ODBAGet(cmd);
		name="GateSize"+i;
		cmd="/Analyzer/Parameters/Gate"+i+"/size";
		document.getElementById(name).value=ODBAGet(cmd);
	}
}

function refreshAll(){
	var this_run_num,// = ODBGet("/Runinfo/Run number"),
		running,//=ODBGet("/Runinfo/State"),
		data, img, Num, h, t, x, y, z, rate, obj, currentTime, hrs, mins, secs, TimeNow, timeElapsed,
		newLevels = [],
		paths = [];

	paths[0] = "/Runinfo/Run number";
	paths[1] = "/Runinfo/State";
	paths[2] = "/Analyzer/Parameters/Statistics/TotalRate";
	paths[3] = "/Analyzer/Parameters/Statistics/TotalInt";
	paths[4] = "/Analyzer/Parameters/Statistics/GateRate";
	paths[5] = "/Analyzer/Parameters/Statistics/GateInt";
	paths[6] = "/Analyzer/Parameters/Statistics/GateRate1";
	paths[7] = "/Analyzer/Parameters/Statistics/GateInt1";
	paths[8] = "/Analyzer/Parameters/Statistics/GateRate2";
	paths[9] = "/Analyzer/Parameters/Statistics/GateInt2";
	paths[10] = "/Analyzer/Parameters/Statistics/GateRate3";
	paths[11] = "/Analyzer/Parameters/Statistics/GateInt3";
	paths[12] = "/Analyzer/Parameters/Gate0/Zoom";

	data = ODBAMGet(paths);
	this_run_num = data[0];
	running = data[1];


	document.getElementById("run_num").innerHTML='Run # '+this_run_num;

	// Connect to the svg image element
	//img = document.getElementById("svgimage");

	for(Num=4; Num>=0; Num--){
		if(Num==0){ 
			h=data[2]//ODBGet("/Analyzer/Parameters/Statistics/TotalRate");
			t=data[3]//ODBGet("/Analyzer/Parameters/Statistics/TotalInt");
		} else if(Num==1){ 
			h=data[4]//ODBGet("/Analyzer/Parameters/Statistics/GateRate"); 
			t=data[5]//ODBGet("/Analyzer/Parameters/Statistics/GateInt");
		} else{ 
			//x="/Analyzer/Parameters/Statistics/GateRate"+(Num-1); 
			h=data[6+2*(Num-2)]//ODBGet(x); 
			//x='/Analyzer/Parameters/Statistics/GateInt'+(Num-1); 
			t=data[6+2*(Num-2)+1]//ODBGet(x);
		}
		TBparam.rate[Num] = h;
		TBparam.int[Num] = t;
		rate=parseInt(h)
		newLevels[Num] = rate;
	}

	//reproduce the svg in canvas:
	for(Num=4; Num>=0; Num--){
		TBparam.oldLevels[Num] = TBparam.levels[Num];
		TBparam.levels[Num] = newLevels[Num];
	}
	updateBars(0);


	//obj=document.getElementById("2Dplot");  //intended to force a source refresh?  Very slow.
	//obj.src=obj.src;
	//document.getElementById("zoom_drop").selectedIndex=parseFloat(data[12])-1//ODBGet("/Analyzer/Parameters/Gate0/Zoom")-1;


	// Print the time of the refresh
	currentTime = new Date();
	hrs = currentTime.getHours();
	if(hrs < 10) hrs="0"+hrs;
	mins = currentTime.getMinutes();
	if(mins < 10) mins="0"+mins;
	secs = currentTime.getSeconds();
	if(secs < 10) secs="0"+secs;

	TimeNow=hrs+":"+mins+":"+secs
	document.getElementById("dateLine").innerHTML=currentTime;

	timeElapsed = Math.floor(currentTime.getTime()/1000)-TBparam.ResetTime
	document.getElementById("Time_display").innerHTML=(timeElapsed);

	if(running==1){
		document.getElementById("run_status").style['background-color'] = '#FF0000';
		document.getElementById("run_status").innerHTML="Data Collecting Stopped";
		TBparam.runTimer = 0;
	} else {
		document.getElementById("run_status").style['background-color'] = '#00FF00';
		if(TBparam.runTimer < 500 && TBparam.runTimer > 0){	
			TBparam.runTimer = 300-timeElapsed
			if(TBparam.runTimer>=0) document.getElementById("run_status").innerHTML= TBparam.runTimer + " s left in run";
			else{
				document.getElementById("run_status").innerHTML= '5 min run finalizing'
				document.getElementById("run_status").style['background-color'] = '#FFFF00';
			}
		} else if(TBparam.runTimer <= 0){  //5 min run is complete, suspend refresh and save ascii:
			document.getElementById("run_status").innerHTML= '5 min run finalizing'
			document.getElementById("run_status").style['background-color'] = '#FFFF00';
			window.clearTimeout(SVparam.refreshHandler2D);
			window.clearTimeout(SVparam.meterRefreshHandler2D);
			document.getElementById('saveASCIIB').onclick();
			SVparam.RefreshTime = 0;
			document.getElementById("refreshRate2D").value = SVparam.RefreshTime;
		} else
			document.getElementById("run_status").innerHTML="Perpetual Run Active";
	}

	//if(SVparam.RefreshTime > 0)SVparam.meterRefreshHandler2D = setTimeout("refreshAll()",SVparam.RefreshTime*1000);
	//users demand faster bar refresh
	SVparam.meterRefreshHandler2D = setTimeout("refreshAll()",1000);
}

function updateBars(frame){
	//console.log(TBparam.num_gates)
	var duration = 0.3,
		FPS = 30,
		nFrame = Math.floor(FPS*duration),
		canvas = document.getElementById('rateBars'),
		context = canvas.getContext('2d'),
		textGutter = canvas.width*0.08,//60,
		leftMargin = canvas.width*0.08,//40,
		bottomMargin = canvas.width*0.05,
		barWidth = canvas.width*0.1,//70,
		yAxisLength = canvas.height*0.70 - bottomMargin,
		tickLength = 5,
		lineWidth = 1,
		height, i, j, string;

		//style context:
		context.strokeStyle = '#FFFFFF';
		context.fillStyle = '#FFFFFF';
		context.font = (16*window.innerWidth/1440)+'px Arial';
		context.lineWidth = lineWidth;

		//clear canvas:
		context.clearRect(0,0,1000,1000);

		//bars
		for(i=0; i<=parseInt(TBparam.num_gates)+1; i++){
			//console.log()
			context.fillStyle = TBparam.barChartColors[i];
			height = TBparam.oldLevels[i]/TBparam.GateMax[i]*yAxisLength + ( TBparam.levels[i] / TBparam.GateMax[i] - TBparam.oldLevels[i] / TBparam.GateMax[i] )*yAxisLength*frame/nFrame;
			if(height>yAxisLength) height = yAxisLength;
			if(height<0) height = 0;
			context.fillRect(leftMargin + textGutter + i*(barWidth+textGutter), canvas.height - bottomMargin - height, barWidth, height);
		}

		//draw frames
		for(i=0; i<=TBparam.num_gates+1; i++){
			//frame
			context.strokeRect(leftMargin + textGutter + i*(barWidth+textGutter), canvas.height-bottomMargin-yAxisLength, barWidth, yAxisLength);
			//ticks
			for(j=0; j<5; j++){
				context.beginPath();
				context.moveTo(leftMargin + textGutter + i*(barWidth+textGutter), canvas.height - bottomMargin - j/4*yAxisLength);
				context.lineTo(leftMargin + textGutter + i*(barWidth+textGutter) - tickLength, canvas.height - bottomMargin - j/4*yAxisLength);
				context.stroke();
				context.textBaseline = 'middle';
				context.fillStyle = '#FFFFFF'
				context.save();
				context.translate(leftMargin + textGutter + i*(barWidth+textGutter) - tickLength - 10, canvas.height - bottomMargin - j/4*yAxisLength);
				context.rotate(-Math.PI/2)
				context.fillText(j*TBparam.GateMax[i]/4000, -context.measureText(j*TBparam.GateMax[i]/4000).width/2, 0 );
				context.restore();
			}
			//x-axis labels
			context.textBaseline = 'top';
			string = ( (i==0) ? 'Total' : 'Gate '+i );
			context.fillText(string, leftMargin + textGutter + barWidth/2 + i*(barWidth+textGutter) - context.measureText(string).width/2, canvas.height-bottomMargin+5);
		}
		
		//y-axis title
		context.textBaseline = 'top';
		context.save();
		context.translate(leftMargin/2, canvas.height-bottomMargin-yAxisLength/2 + context.measureText('Rate (Hz)').width/2);
		context.rotate(-Math.PI/2);
		context.fillText('Rate (kHz)', 0,0);
		context.restore();

		//bar summary data
		context.textBaseline = 'middle';
		for(i=0; i<=TBparam.num_gates+1; i++){
			context.save()
			context.translate(leftMargin+textGutter+barWidth/2 + i*(barWidth+textGutter), canvas.height-bottomMargin-yAxisLength-5 );
			context.rotate(-Math.PI/2);
			context.fillText('Rate: '+parseFloat(TBparam.rate[i]).toExponential(1), 0, -20);
			context.fillText('Int: '+parseFloat(TBparam.int[i]).toExponential(1), 0, 20);
			context.restore();
		}

		//call next animation frame:
		if(frame < nFrame) setTimeout(function(){updateBars(frame+1)}, 1000/FPS);

}

function setZoom(factor){
	ODBASet("/Analyzer/Parameters/Gate0/Zoom",factor);
}

function setGateX(num){
	var thisid=num.id,
		cmd="/Analyzer/Parameters/Gate"+thisid.substring(5,6)+"/x",
		factor=document.getElementById(thisid).value;
		console.log([cmd,factor])
	ODBASet(cmd,factor);
}

function setGateY(num){
	var thisid=num.id,
		cmd="/Analyzer/Parameters/Gate"+thisid.substring(5,6)+"/y",
		factor=document.getElementById(thisid).value;
	ODBASet(cmd,factor);
}

function setGateSize(num){
	var thisid=num.id,
		cmd="/Analyzer/Parameters/Gate"+thisid.substring(8,9)+"/size",
		factor=document.getElementById(thisid).value;
		console.log([cmd,factor])
	ODBASet(cmd,factor);
} 

function setResetTime(){
	//send the refresh down to the ODB
	ODBASet('/Analyzer/Parameters/Gate0/reset', 1);

	// Print the time of the refresh
	TBparam.ResetTime = new Date();
	TBparam.ResetTime = Math.floor(TBparam.ResetTime.getTime()/1000);
	ODBASet("/Analyzer/Parameters/Gate0/ResetTime",TBparam.ResetTime);
}

function dump2D(){
	var currentTime, year, month, day, hrs, mins, filename;

	// Get the time
	currentTime = new Date();
	year = currentTime.getFullYear();
	month = currentTime.getMonth();	
	month = parseInt(month)+1;
	if(month < 10) month="0"+month;
	day = currentTime.getDate();
	hrs = currentTime.getHours();
	if(hrs < 10) hrs="0"+hrs;
	mins = currentTime.getMinutes();
	if(mins < 10) mins="0"+mins;

	filename="bragg-"+year+month+day+"-"+hrs+mins+".dat";
	//  filename=prompt("Please enter filename including the extension:","");
	ODBASet("/Analyzer/Parameters/Gate0/dumpname",filename);
	ODBASet("/Analyzer/Parameters/Gate0/dump",1);
	alert("The file \""+filename+"\" has been written on the lxdaq04 filesystem.");
}

//special extention to mhttpd to handle 2D data
function getData2D(specid){
	var request = XMLHttpRequestGeneric();

	var url = "?cmd=getspec2d&value="+specid;
	request.open('GET', url, false);
	request.send(null);

	//var tempArray = request.responseText.split(";");
	//for(var i=0; i<tempArray.length; i++) { tempArray[i] = +tempArray[i]; }

	//return tempArray;
    return request.responseText;
}

function reportSpectrumBin(){
	SVparam.canvas.addEventListener('mousemove', function(event){
		var coords, x, y, xBin, yBin;

		coords = document.getElementById(SVparam.canvasID).relMouseCoords(event);
		x = coords.x;
		y = coords.y;

        if(x > SVparam.leftMargin && x < SVparam.canvas.width - SVparam.rightMargin && y > SVparam.topMargin){
	        xBin = Math.floor((x-SVparam.leftMargin)/SVparam.binWidth) + SVparam.XaxisLimitMin;
    	    
    	    if(SVparam.AxisType == 1){
    	    	yBin = (SVparam.canvas.height-SVparam.bottomMargin - y) / SVparam.countHeight;
    	    	yBin = Math.floor(Math.pow(10,yBin)/10);
    	    } else {
    	    	yBin = Math.floor((SVparam.canvas.height-SVparam.bottomMargin - y) / SVparam.countHeight);
    	    }

        	document.getElementById('mousebox').innerHTML = 'x=' + xBin.toFixed(0) + ' y=' + yBin.toFixed(0);
        } else {
        	document.getElementById('mousebox').innerHTML = '';
        }

        //change cursor to indicate draggable region:
        if(SVparam.fitModeEngage){
        	if( y < (SVparam.canvas.height - SVparam.bottomMargin) )
	        	document.body.style.cursor = 's-resize';
	        else 
	        	document.body.style.cursor = 'n-resize';
	    }
        else if(y>SVparam.canvas.height-SVparam.bottomMargin) 
        	document.body.style.cursor = 'pointer';
        else
        	document.body.style.cursor = 'default';

	}, false);

	SVparam.canvas.onmouseout = function(event){
		document.body.style.cursor = 'default';
	};
}

function DragWindow(){
	var buffer;

	//don't even try if there's only one bin selected:
	if(SVparam.XMouseLimitxMin != SVparam.XMouseLimitxMax){
		//don't confuse the click limits with the click and drag limits:
		SVparam.clickBounds[0] = 'abort';

		//Make sure the max is actually the max:
		if(SVparam.XMouseLimitxMax < SVparam.XMouseLimitxMin){
			buffer = SVparam.XMouseLimitxMax;
			SVparam.XMouseLimitxMax = SVparam.XMouseLimitxMin;
			SVparam.XMouseLimitxMin = buffer;
		}

		//keep things in range
		if(SVparam.XMouseLimitxMin < 0) SVparam.XMouseLimitxMin = 0;
		if(SVparam.XMouseLimitxMax > SVparam.XaxisLimitAbsMax) SVparam.XMouseLimitxMax = SVparam.XaxisLimitAbsMax;

		//stick into the appropriate globals
		SVparam.XaxisLimitMin = parseInt(SVparam.XMouseLimitxMin);
		SVparam.XaxisLimitMax = parseInt(SVparam.XMouseLimitxMax);

		//populate the text fields:
		document.getElementById("LowerXLimit").value=SVparam.XaxisLimitMin;
		document.getElementById("UpperXLimit").value=SVparam.XaxisLimitMax;	
		//programatically trigger the fields' onchange:
		document.getElementById('LowerXLimit').onchange();
		document.getElementById('UpperXLimit').onchange();

		//drawXaxis();
		SVparam.YaxisLimitMax=5;

		plot_data(0);

	}
}

function ClickWindow(bin){

	//decide what to do with the clicked limits - zoom or fit?
	if(SVparam.clickBounds.length == 0){
		SVparam.clickBounds[0] = bin;
	} else if(SVparam.clickBounds[0] == 'abort' && !SVparam.fitModeEngage){
		SVparam.clickBounds = [];
	} else if(SVparam.clickBounds.length == 2 ){
		SVparam.clickBounds = [];
		SVparam.clickBounds[0] = bin;
	} else if(SVparam.clickBounds.length == 1){
		SVparam.clickBounds[1] = bin;
		//fit mode
		if(SVparam.fitModeEngage){
			SVparam.FitLimitLower = Math.min(SVparam.clickBounds[0], SVparam.clickBounds[1]);
			SVparam.FitLimitUpper = Math.max(SVparam.clickBounds[0], SVparam.clickBounds[1]);
			FitData();
		} else {  //zoom mode
			//use the mouse drag function to achieve the same effect for clicking:
			SVparam.XMouseLimitxMin = SVparam.clickBounds[0];
			SVparam.XMouseLimitxMax = SVparam.clickBounds[1];
			DragWindow();
			SVparam.clickBounds = [];
		}
	}
}

function setAxisLimit(input, fieldID, target, absMax){
	var field = document.getElementById(fieldID)
	if(field.validity.valid){

		//mins are always protected to be > 0 from the HTML, but maxs need to be babysat:
		if(field.value > SVparam[absMax])
			field.value = SVparam[absMax];

		//input the number requested...
		SVparam[target]=input;

		//...and make sure it makes sense.
		if(SVparam[target]>SVparam[absMax])
			SVparam[target]=SVparam[absMax];

		if(SVparam[target]<0) 
			SVparam[target]=0;

	} else {  //exception handling, bump the value back to whatever it used to be.
		field.value = SVparam[target];
	}
}

function scrollSpectra(step, targetMin, targetMax, targetAbsMax, loField, hiField){
	var windowSize = SVparam[targetMax] - SVparam[targetMin];

	SVparam[targetMin] += step;
	SVparam[targetMax] += step;

	if(SVparam[targetMin] < 0){
		SVparam[targetMin] = 0;
		SVparam[targetMax] = windowSize;
	}

	if(SVparam[targetMax] > SVparam[targetAbsMax]){
		SVparam[targetMax] = SVparam[targetAbsMax];
		SVparam[targetMin] = SVparam[targetAbsMax] - windowSize;
	}

	document.getElementById(loField).value = SVparam[targetMin];
	document.getElementById(loField).onchange();
	document.getElementById(hiField).value = SVparam[targetMax];
	document.getElementById(hiField).onchange();
}

function Unzoom(){

	//1D
	if(document.getElementById('LowerXLimit')){
		SVparam.XaxisLimitMin=0;
		SVparam.XaxisLimitMax=SVparam.XaxisLimitAbsMax;

		//update input field values and trigger their onchange:
		document.getElementById("LowerXLimit").value=SVparam.XaxisLimitMin;
		document.getElementById("UpperXLimit").value=SVparam.XaxisLimitMax;
		document.getElementById('LowerXLimit').onchange();
		document.getElementById('UpperXLimit').onchange();

		plot_data(0);
	}

	//2D
	if(document.getElementById('LowerXLimit2D')){
		SVparam.XaxisLimitMin2D = 0;
		SVparam.XaxisLimitMax2D = SVparam.XaxisLimitAbsMax2D;
		SVparam.YaxisLimitMin2D = 0;
		SVparam.YaxisLimitMax2D = SVparam.YaxisLimitAbsMax2D;

		document.getElementById("LowerXLimit2D").value=SVparam.XaxisLimitMin2D;
		document.getElementById("UpperXLimit2D").value=SVparam.XaxisLimitMax2D;
		document.getElementById("LowerYLimit").value=SVparam.YaxisLimitMin2D;
		document.getElementById("UpperYLimit").value=SVparam.YaxisLimitMax2D;

		plot_data2D(0);	
	}

}

/////////////////////////////////////////////////////////////////////
// set_SVparam.AxisType function                                   //
// Function to change to and from Linear and Logarithmic Y axis    //
/////////////////////////////////////////////////////////////////////
function set_AxisType(word){
	var x;

	//TODO: overkill, simplify:
	x=word.id;
	SVparam.AxisType=x.substring(1,2);
	x=x.substring(0,1)+"0"; document.getElementById(x+"").checked=false;
	x=x.substring(0,1)+"1"; document.getElementById(x+"").checked=false;
	x=word.id; document.getElementById(x+"").checked=true;
	SVparam.AxisType=word.value;

	if(SVparam.AxisType==0){
		SVparam.YaxisLimitMin=0;
		SVparam.YaxisLimitMax=500;
	}

	if(SVparam.AxisType==1){
		SVparam.YaxisLimitMin=0.1;
		SVparam.YaxisLimitMax=SVparam.YaxisLimitMax*100;  //?? okay I guess...
	}	
	plot_data(0);
}
//////////////////////////////////
// End of set_SVparam.AxisType function //
//////////////////////////////////


/////////////////////////////////////////////////////////////////////
// startup function                                                //
// Function to draw everything the first time when page is loaded  //
/////////////////////////////////////////////////////////////////////
function startup(){
	var iframe, iframeDoc, row, table;

	// Setup the mouse coordinate printing on the screen
	reportSpectrumBin();

	document.getElementById(SVparam.canvasID).onmousedown = function(event){
			SVparam.XMouseLimitxMin = parseInt((document.getElementById(SVparam.canvasID).relMouseCoords(event).x-SVparam.leftMargin)/SVparam.binWidth + SVparam.XaxisLimitMin);
		};
	document.getElementById(SVparam.canvasID).onmouseup = function(event){
			SVparam.XMouseLimitxMax = parseInt((document.getElementById(SVparam.canvasID).relMouseCoords(event).x-SVparam.leftMargin)/SVparam.binWidth + SVparam.XaxisLimitMin); 
			DragWindow();
			ClickWindow( parseInt((document.getElementById(SVparam.canvasID).relMouseCoords(event).x-SVparam.leftMargin)/SVparam.binWidth + SVparam.XaxisLimitMin) );
		}

	document.getElementById(SVparam.canvasID2D).onmousedown = function(event){mDown2D(event)};
	document.getElementById(SVparam.canvasID2D).onmouseup = function(event){mUp2D(event)};
	SVparam.canvas2D.addEventListener('mousemove', function(event){mMove2D(event)}, false);
	document.getElementById(SVparam.canvasID2D).onmouseout = function(event){document.getElementById('2Dcoords').innerHTML=''};


	iframe = document.getElementById('menu_iframe');
	iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
	iframeDoc.open();
	iframeDoc.write('<body style="background:#333333; color:#999999; font-family:'+ "'" +'Raleway'+ "'" +', sans-serif;"> <table id="main_table" width="100%"></table></body>');
	iframeDoc.close();

	table = iframeDoc.getElementById("main_table");
	row = table.insertRow(0);
	row.innerHTML ="Welcome! To begin click 'Load Spectra' below.";

}
///////////////////////////////
// End of startup function   //
///////////////////////////////

/////////////////////////////////////////////////////////////////////
// Math.log10 function                                             //
// Function to calculate the logarithm with base 10 of the number  //
/////////////////////////////////////////////////////////////////////
Math.log10 = function(n) {
	return (Math.log(n)) / (Math.log(10));
}
////////////////////////////////
// End of Math.log10 function //
////////////////////////////////

/////////////////////////////////////////////////////////////////////
// resetData function                                              //
// Function to zero the data array and in the ODB                  //
/////////////////////////////////////////////////////////////////////
function resetData(){
	var i;
	// Zero the data array in the ODB
	// ODBSet("/Analyzer/Parameters/Gate0/reset",1);

	// Zero the data array
	for(i=0; i<512; i++) SVparam.data[i]=0;

	// Redraw with the zeroed data values 
	plot_data(0);
}  
///////////////////////////////
// End of resetData function //
///////////////////////////////

/////////////////////////////////////////////////////////////////////
// plot_data function                                              //
// Function to reload and redraw the data points in the spectrum   //
// Two data display options are available, Stairs and Points       //
// Stairs option: The coordinates of a polyline are saved for each //
// data point. The coordinates are then set in the svg element.    //
// Points option: The coordinates of each data point are saved     //
// directly as the coordinates of a svg circle element.            //
// If the data exceeds the Y limit or the maximum value is well    //
// below the limit then the axis will be redrawn                   //
/////////////////////////////////////////////////////////////////////
function plot_data(RefreshNow, abandonBuffer){
	var i, j, data, thisSpec,
	thisData = [];
	SVparam.entries = [];
	
	SVparam.YaxisLimitMax=5;
	SVparam.XaxisLength = SVparam.XaxisLimitMax - SVparam.XaxisLimitMin;

	//abandon the fit when re-drawing the plot
	if(SVparam.Fitted==1){
		document.getElementById('fitbox').innerHTML = '';
		SVparam.Fitted=0;
	}

	SVparam.maxYvalue=SVparam.YaxisLimitMax;
	// Loop through to get the data and set the Y axis limits
	for(thisSpec=0; thisSpec<SVparam.DisplayedSpecs.length; thisSpec++){
		// Here call function to get data from the server
		// thisData[thisSpec]=ODBGet("/Test/spectrum_data[*]","%d");
		thisData[thisSpec]=getSpecData(SVparam.DisplayedSpecs[thisSpec], abandonBuffer);

		//Find the maximum X value from the size of the data
		if(thisData[thisSpec].length>SVparam.XaxisLimitAbsMax){
			SVparam.XaxisLimitAbsMax=thisData[thisSpec].length;

			// Create more datapoints here if required for this spectrum
		}

		// Find maximum Y value in the part of the spectrum to be displayed
		if(Math.max.apply(Math, thisData[thisSpec].slice(Math.floor(SVparam.XaxisLimitMin),Math.floor(SVparam.XaxisLimitMax)))>SVparam.maxYvalue){
			SVparam.maxYvalue=Math.max.apply(Math, thisData[thisSpec].slice(Math.floor(SVparam.XaxisLimitMin),Math.floor(SVparam.XaxisLimitMax)));
		}

		// Find the sum of everything in the current x range
		data = thisData[thisSpec].slice(  Math.floor(SVparam.XaxisLimitMin),Math.floor(SVparam.XaxisLimitMax)   );
		SVparam.totalEntries = 0;
		for(j=0; j<data.length; j++ ){
			SVparam.totalEntries += data[j];
		}

		//report number of entries on canvas:
		SVparam.entries[thisSpec] = SVparam.totalEntries;

	}// End of for loop

	// Adjust the Y axis limit and compression and redraw the axis
	if(SVparam.maxYvalue>5){
		if(SVparam.AxisType==0) SVparam.YaxisLimitMax=Math.floor(SVparam.maxYvalue*1);
		if(SVparam.AxisType==1) SVparam.YaxisLimitMax=SVparam.maxYvalue*10;
	} else {
		if(SVparam.AxisType==0) SVparam.YaxisLimitMax=5;
		if(SVparam.AxisType==1) SVparam.YaxisLimitMax=50;
	}

	if(SVparam.AxisType==0)
		SVparam.YaxisLength=SVparam.YaxisLimitMax-SVparam.YaxisLimitMin;

	if(SVparam.AxisType==1)
		SVparam.YaxisLength=Math.log10(SVparam.YaxisLimitMax-SVparam.YaxisLimitMin);

	drawFrame();

	// Now the limits are set loop through and plot the data points
	for(thisSpec=0; thisSpec<SVparam.DisplayedSpecs.length; thisSpec++){

		SVparam.context.textBaseline = 'top';
		SVparam.context.fillStyle = SVparam.dataColor[thisSpec];
		SVparam.context.fillText('Entries: '+SVparam.entries[thisSpec], SVparam.canvas.width - SVparam.rightMargin - SVparam.context.measureText('Entries: '+SVparam.entries[thisSpec]).width, thisSpec*16);

		SVparam.data=thisData[thisSpec].slice();

		// Loop through the data spectrum that we have
		//start the canvas path:
		SVparam.context.strokeStyle = SVparam.dataColor[thisSpec];
		SVparam.context.beginPath();
		SVparam.context.moveTo(SVparam.leftMargin, SVparam.canvas.height - SVparam.bottomMargin);
		for(i=Math.floor(SVparam.XaxisLimitMin); i<Math.floor(SVparam.XaxisLimitMax); i++){

			// Protection at the end of the spectrum (minimum and maximum X)
			if(i<SVparam.XaxisLimitMin || i>SVparam.XaxisLimitMax) continue;

			// Protection in Overlay mode for spectra which are shorter (in x) than the longest spectrum overlayed.
			if(i>=SVparam.data.length) continue;

			// If using Stairs data display
			// Record the coordinates of this data point along the polyline
			// The coordinates are set following this for loop
			if(SVparam.DataType==0){
				if(SVparam.AxisType==0){
					//draw canvas line:
					//left side of bar
					SVparam.context.lineTo( SVparam.leftMargin + (i-SVparam.XaxisLimitMin)*SVparam.binWidth, SVparam.canvas.height - SVparam.bottomMargin - SVparam.data[i]*SVparam.countHeight );
					//top of bar
					SVparam.context.lineTo( SVparam.leftMargin + (i+1-SVparam.XaxisLimitMin)*SVparam.binWidth, SVparam.canvas.height - SVparam.bottomMargin - SVparam.data[i]*SVparam.countHeight );
				}

				if(SVparam.AxisType==1){
					//draw canvas line:
					if(SVparam.data[i] > 0){
						//left side of bar
						SVparam.context.lineTo( SVparam.leftMargin + (i-SVparam.XaxisLimitMin)*SVparam.binWidth, SVparam.canvas.height - SVparam.bottomMargin - (Math.log10(SVparam.data[i]) - Math.log10(SVparam.YaxisLimitMin))*SVparam.countHeight );
						//top of bar
						SVparam.context.lineTo( SVparam.leftMargin + (i+1-SVparam.XaxisLimitMin)*SVparam.binWidth, SVparam.canvas.height - SVparam.bottomMargin - (Math.log10(SVparam.data[i]) - Math.log10(SVparam.YaxisLimitMin))*SVparam.countHeight );
					} else {
						//drop to the x axis
						SVparam.context.lineTo( SVparam.leftMargin + (i-SVparam.XaxisLimitMin)*SVparam.binWidth, SVparam.canvas.height - SVparam.bottomMargin );
						//crawl along x axis until log-able data is found:
						SVparam.context.lineTo( SVparam.leftMargin + (i+1-SVparam.XaxisLimitMin)*SVparam.binWidth, SVparam.canvas.height - SVparam.bottomMargin );
					}
				}

			}

		}
		//finish the canvas path:
		SVparam.context.lineTo(SVparam.canvas.width - SVparam.rightMargin, SVparam.canvas.height - SVparam.bottomMargin );
		SVparam.context.closePath();
		SVparam.context.stroke();

	} // End of for loop

	// Pause for some time and then recall this function to refresh the data display
	if(SVparam.RefreshTime>0 && RefreshNow==1) SVparam.refreshHandler = setTimeout(function(){plot_data(1, 'true')},SVparam.RefreshTime*1000); 
	
}
///////////////////////////////
// End of plot_data function //
///////////////////////////////

//draw the plot frame
function drawFrame(){
	var binsPerTick, countsPerTick, i, label;

	//determine bin render width
	SVparam.binWidth = SVparam.xAxisPixLength / (SVparam.XaxisLimitMax - SVparam.XaxisLimitMin);
	//determine the scale render height per count for linear view:
	SVparam.countHeight = SVparam.yAxisPixLength / SVparam.YaxisLength;

	//clear canvas
	SVparam.context.clearRect(0,0,SVparam.canvWidth, SVparam.canvHeight);

	//draw principle axes:
	SVparam.context.strokeStyle = '#FFFFFF';
	SVparam.context.fillStyle = '#FFFFFF';
	SVparam.context.lineWidth = 1;
	SVparam.context.beginPath();
	SVparam.context.moveTo(SVparam.leftMargin, SVparam.topMargin);
	SVparam.context.lineTo(SVparam.leftMargin, SVparam.canvas.height-SVparam.bottomMargin);
	SVparam.context.lineTo(SVparam.canvas.width - SVparam.rightMargin, SVparam.canvas.height - SVparam.bottomMargin);
	SVparam.context.stroke();

	//Decorate x axis////////////////////////////////////////////////////////
	//decide how many ticks to draw on the x axis:
	SVparam.nXticks = 6;

	//come as close to a factor of the number of bins as possible:
	while( Math.floor(SVparam.XaxisLength / SVparam.nXticks) == Math.floor(SVparam.XaxisLength / (SVparam.nXticks-1)) )
		SVparam.nXticks--;
	//draw at most one tick per bin:
	if(SVparam.XaxisLength < (SVparam.nXticks-1) )
		SVparam.nXticks = SVparam.XaxisLength+1

	//how many bins should there be between each tick?
	binsPerTick = Math.floor((SVparam.XaxisLimitMax - SVparam.XaxisLimitMin) / (SVparam.nXticks-1));

	//draw x axis ticks & labels:
	for(i=0; i<SVparam.nXticks; i++){
		//ticks
		SVparam.context.beginPath();
		SVparam.context.moveTo(SVparam.leftMargin + i*binsPerTick*SVparam.binWidth, SVparam.canvas.height - SVparam.bottomMargin);
		SVparam.context.lineTo(SVparam.leftMargin + i*binsPerTick*SVparam.binWidth, SVparam.canvas.height - SVparam.bottomMargin + SVparam.tickLength);
		SVparam.context.stroke();

		//labels
		label = (SVparam.XaxisLimitMin + i*binsPerTick).toFixed(0);
		SVparam.context.textBaseline = 'top';
		SVparam.context.fillText(label, SVparam.leftMargin + i*binsPerTick*SVparam.binWidth - SVparam.context.measureText(label).width/2, SVparam.canvas.height - SVparam.bottomMargin + SVparam.tickLength + SVparam.xLabelOffset);
	}

	//Decorate Y axis/////////////////////////////////////////////////////////
	//decide how many ticks to draw on the y axis:
	SVparam.nYticks = 5;
	//come as close to a factor of the number of bins as possible:
	while( Math.floor(SVparam.YaxisLength / SVparam.nYticks) == Math.floor(SVparam.YaxisLength / (SVparam.nYticks-1)) )
		SVparam.nYticks--;

	//how many counts should each tick increment?
	countsPerTick = Math.floor(SVparam.YaxisLength / (SVparam.nYticks-1));

	//draw y axis ticks and labels:
	for(i=0; i<SVparam.nYticks; i++){
		//ticks
		SVparam.context.beginPath();
		SVparam.context.moveTo(SVparam.leftMargin, SVparam.canvas.height - SVparam.bottomMargin - i*countsPerTick*SVparam.countHeight);
		SVparam.context.lineTo(SVparam.leftMargin - SVparam.tickLength, SVparam.canvas.height - SVparam.bottomMargin - i*countsPerTick*SVparam.countHeight);
		SVparam.context.stroke();

		//labels
		SVparam.context.textBaseline = 'middle';
		if(SVparam.AxisType == 0){ //linear scale
			label = (SVparam.YaxisLimitMax<10000) ? (i*countsPerTick).toFixed(0) : (i*countsPerTick).toExponential(1);
			SVparam.context.fillText(label, SVparam.leftMargin - SVparam.tickLength - SVparam.yLabelOffset - SVparam.context.measureText(label).width, SVparam.canvas.height - SVparam.bottomMargin - i*countsPerTick*SVparam.countHeight);
		} else {  //log scale
			label = i*countsPerTick-1;
			//exponent
			SVparam.context.font = SVparam.expFont;
			SVparam.context.fillText(label, SVparam.leftMargin - SVparam.tickLength - SVparam.yLabelOffset - SVparam.context.measureText(label).width, SVparam.canvas.height - SVparam.bottomMargin - i*countsPerTick*SVparam.countHeight - 10);
			//base
			SVparam.context.font = SVparam.baseFont;
			SVparam.context.fillText('10', SVparam.leftMargin - SVparam.tickLength - SVparam.yLabelOffset - SVparam.context.measureText('10'+label).width, SVparam.canvas.height - SVparam.bottomMargin - i*countsPerTick*SVparam.countHeight);
		}
	}

	//x axis title:
	SVparam.context.textBaseline = 'bottom';
	SVparam.context.fillText('Channels', SVparam.canvas.width - SVparam.rightMargin - SVparam.context.measureText('Channels').width, SVparam.canvas.height);

	//y axis title:
	SVparam.context.textBaseline = 'alphabetic';
	SVparam.context.save();
	SVparam.context.translate(SVparam.leftMargin*0.25, SVparam.context.measureText('Counts').width + SVparam.topMargin );
	SVparam.context.rotate(-Math.PI/2);
	SVparam.context.fillText('Counts', 0,0);
	SVparam.context.restore();

}

function RequestFitLimits(){
	var x;

	//enter fit mode:
	SVparam.fitModeEngage = 1;

	SVparam.FitLimitLower=-1;
	SVparam.FitLimitUpper=-1;

	document.getElementById('fitbox').innerHTML = 'Select fit region with Mouse clicks';

}

function FitData(){
	var cent, fitdata, i, max, width, x, y, height;

	//suspend the refresh
	window.clearTimeout(SVparam.refreshHandler);
	//set refresh option to 'off'
	document.getElementById("refreshRate").value = 0;

	if(SVparam.FitLimitLower<0) SVparam.FitLimitLower=0;
	if(SVparam.FitLimitUpper>SVparam.XaxisLimitAbsMax) SVparam.FitLimitUpper=SVparam.XaxisLimitAbsMax;

	max=1;

	fitdata=getSpecData(SVparam.DisplayedSpecs[0]);
	fitdata=fitdata.slice(SVparam.FitLimitLower,SVparam.FitLimitUpper);

	// Find maximum Y value in the fit data
	if(Math.max.apply(Math, fitdata)>max){
		max=Math.max.apply(Math, fitdata);
	}

	// Find the bin with the maximum Y value
	cent=0;
	while(fitdata[cent]<max){
		cent++;
	}

	// Find the width of the peak
	x=cent;
	while(fitdata[x]>(max/2.0)) x--; 
	width=x;
	x=cent;
	while(fitdata[x]>(max/2.0)) x++; 
	width=x-width;
	if(width<1) width=1;
	width/=2.35;

	cent=cent+SVparam.FitLimitLower+0.5;

	//set up canvas for drawing fit line
	SVparam.context.lineWidth = 3;
	SVparam.context.strokeStyle = '#FF0000';
	SVparam.context.beginPath();
	SVparam.context.moveTo( SVparam.leftMargin + (SVparam.FitLimitLower-SVparam.XaxisLimitMin)*SVparam.binWidth, SVparam.canvas.height - SVparam.bottomMargin - max*Math.exp(-1*(((SVparam.FitLimitLower-cent)*(SVparam.FitLimitLower-cent))/(2*width*width)))*SVparam.countHeight);

	for(i=0;i<fitdata.length;i+=0.2){
		//draw fit line on canvas:
		x=i+SVparam.FitLimitLower;
		y = max*Math.exp(-1*(((x-cent)*(x-cent))/(2*width*width)));
		if(i!=0){
			if(SVparam.AxisType == 0){
				SVparam.context.lineTo( SVparam.leftMargin + (SVparam.FitLimitLower-SVparam.XaxisLimitMin)*SVparam.binWidth + i*SVparam.binWidth, SVparam.canvas.height - SVparam.bottomMargin - y*SVparam.countHeight);
			} else if(SVparam.AxisType == 1){
				if(y<=0) height = 0;
				else height = Math.log10(y) - Math.log10(SVparam.YaxisLimitMin);
				if(height<0) height = 0;

				SVparam.context.lineTo( SVparam.leftMargin + (SVparam.FitLimitLower-SVparam.XaxisLimitMin)*SVparam.binWidth + i*SVparam.binWidth, SVparam.canvas.height - SVparam.bottomMargin - height*SVparam.countHeight);
			}
		}
	}

	SVparam.context.stroke();

	SVparam.word = 'Height = ' + max + ' Width = ' + width.toFixed(3) + ' Centroid = ' + cent;
	document.getElementById('fitbox').innerHTML = SVparam.word;
	SVparam.word = 'H=' + max + ',W=' + width.toFixed(3) + ',C=' + cent + "; ";
	document.getElementById('spec_fits0').innerHTML = SVparam.word+document.getElementById('spec_fits0').innerHTML;

	SVparam.Fitted=1;
	SVparam.fitModeEngage = 0;
}

function Menu_unSelectAll(){
	var i, iframe, iframeDoc, j;

	document.getElementById("displayMistake").innerHTML="";
	iframe = document.getElementById('menu_iframe');
	iframeDoc = iframe.contentDocument || iframe.contentWindow.document;

	// Reset the properties of the rows which were selected
	j=0;
	if(SVparam.Specs.length>0){
		while(j<SVparam.Specs.length){
			i=SVparam.Specs[j];
			iframeDoc.getElementById("row"+i).style['background-color'] = "#333333";
			iframeDoc.getElementById("row"+i).setAttribute('onclick', 'parent.Menu_MakeselectSpectrum(event,'+i+')');
			j++;
		}
	}
	SVparam.Specs = [];
}

function SetupGetList(){
	var box, but, i;

	// Black out the screen
	box = document.createElement('div');
	box.setAttribute('id', 'hostnameblankbox');
	box.setAttribute('style', 'position:fixed; top:0; left:0; right:0; bottom:0; border:none; z-index:49; background-color:rgba(190,190,190,0.8); opacity:50%;');
	document.getElementById('holder').appendChild(box);

	// Request the hostname input from the user
	box = document.createElement('div');
	box.setAttribute('id', 'hostnamebox');
	box.setAttribute('style', 'position:fixed; top:180px; left:0; right:0; border:3px solid black; z-index:50; width:500px; margin:auto; background-color:#A0A0FF;');
	box.innerHTML = '<center>Please enter a hostname or select a known one from the list:<table width=100%><tr><td align=center id="enterhostbox"></td></tr><tr><td align=center id="knownhostbox"></td></table></center>';
	document.getElementById('holder').appendChild(box);

	but = document.createElement('input');
	but.setAttribute('type', 'text');
	but.setAttribute('id', 'divtext');
	document.getElementById('enterhostbox').appendChild(but);
	but = document.createElement('input');
	but.setAttribute('type', 'button');
	but.setAttribute('id', 'divtextbutton');
	but.setAttribute('value', 'ok');
	but.setAttribute('onclick', 'GetList(divtext.value)');
	document.getElementById('enterhostbox').appendChild(but);
	but = document.createElement('input');
	but.setAttribute('type', 'button');
	but.setAttribute('id', 'divcancelbutton');
	but.setAttribute('value', 'cancel');
	but.setAttribute('onclick', 'GetList(null)');
	document.getElementById('enterhostbox').appendChild(but);

	for(i=0; i<SVparam.KnownHostnames.length; i++){
		but = document.createElement('input');
		but.setAttribute('type', 'button');
		but.setAttribute('id', 'divbutton'+i);
		but.setAttribute('value', SVparam.KnownHostnames[i]);
		but.setAttribute('onclick', 'GetList(this.value)');
		document.getElementById('knownhostbox').appendChild(but);
	}
}

function GetList(newhost){
	var i, iframe, iframeDoc, Num, row, table, string,
		RemoveTable = 0;

	// Check if a list is already loaded by the hostname being defined
	// if yes then set a flag for the old list to be removed later in this function
	if(SVparam.hostname.length>0) RemoveTable=1; 

	// Set the hostname at the top of the page
    string = document.location.href.slice(7, document.location.href.length);
    string = string.slice(0,string.indexOf('/'));
	document.getElementById('youAreHere').innerHTML="Spectrum Viewer - "+string;

	// Attach to the table for the spectrum list in the iframe
	iframe = document.getElementById('menu_iframe');
	iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
	table = iframeDoc.getElementById("main_table");

	// If a previous list was loaded, delete all rows for it
	if(RemoveTable==1){
		i=0;
		Num=table.rows.length;
		while(i<Num){
			table.deleteRow(0);
			i++;
		}
	}
	else{
		table.deleteRow(0);
	}
	
	if(!SVparam.devMode){
		// Here call the function to Get the spectrum list from the server
	SVparam.spectrum_names = getList();
		for(i=0; i<SVparam.spectrum_names.length; i++){
			row = table.insertRow(i);
			row.setAttribute('id', "row"+i);
			row.setAttribute('background-color', "#333333");
			row.setAttribute('style', "display:block;cursor:default");
			// row.setAttribute('onclick', "parent.Menu_selectSpectrum("+i+")");
			row.setAttribute('onclick', "parent.Menu_MakeselectSpectrum(event,"+i+")");
			row.setAttribute('ondblclick', "parent.displaySpectrum("+i+")");
			row.innerHTML = SVparam.spectrum_names[i];
		}
	} else {
		// Put in fake list info - COMMENT OUT ONCE ABOVE FUNCTION IS WORKING
			for(i=0; i<50; i++){
				row = table.insertRow(i);
				row.setAttribute('id', "row"+i);
				row.setAttribute('background-color', "#333333");
				row.setAttribute('style', "display:block;cursor:default");
				iframeDoc.getElementById('row'+i).onclick = function(event){ parent.Menu_MakeselectSpectrum(event, parseInt(this.id.slice(3,this.id.length+1))  )};
				iframeDoc.getElementById('row'+i).ondblclick = function(){parent.displaySpectrum( parseInt(this.id.slice(3,this.id.length+1)) )};
				row.innerHTML ="Spectrum Name "+i;
				SVparam.spectrum_names[i]="Spectrum Name "+i;

		}
	}


	// Disable text selection in the menu list
	if (typeof iframeDoc.body.onselectstart!="undefined") //IE route
		iframeDoc.body.onselectstart=function(){return false}

	else if (typeof iframeDoc.body.style.MozUserSelect!="undefined") //Firefox route
		iframeDoc.body.style.MozUserSelect="none"

	else //All other route (ie: Opera)
		iframeDoc.body.onmousedown=function(){return false}

	plot_data(1);
}

function DisplaySpecs(){
	var j, num;

	SVparam.XaxisLimitAbsMax=500;
	SVparam.YaxisLimitMax=5;
	document.getElementById("displayMistake").innerHTML="";

	if(SVparam.Specs.length>1){
		document.getElementById("displayMistake").innerHTML="Only one spectrum can be displayed! (use Overlay for multiple spectra)";
		return;
	}
	if(SVparam.Specs.length==0){
		clearSpecs()
		return;
	}

	reset_list_color();
	SVparam.word="";
	num=(SVparam.Specs.length-1);

	if(num>=0){
		while(num>=0){
			List_update(SVparam.Specs[num],0);
			num--;
			if(num<0) break;
		}
	}
	SVparam.DisplayedSpecs=SVparam.Specs.slice();
	SVparam.NumSpecsDisplayed=1;
	Menu_unSelectAll();
	plot_data(0);
}

function OverlaySpecs(){
	var j, x;

	SVparam.XaxisLimitAbsMax=500;
	SVparam.YaxisLimitMax=5;
	document.getElementById("displayMistake").innerHTML="";

	if((SVparam.Specs.length+SVparam.NumSpecsDisplayed)>10){
		document.getElementById("displayMistake").innerHTML="Maximum of 10 spectra can be overlayed";
		return;
	}

	// Plot the spectra
	for(j=0; j<SVparam.Specs.length; j++){
		SVparam.DisplayedSpecs[SVparam.DisplayedSpecs.length]=SVparam.Specs[j];
		List_update(SVparam.Specs[j],SVparam.NumSpecsDisplayed+j);
	}
	plot_data(0);

	SVparam.NumSpecsDisplayed=SVparam.NumSpecsDisplayed+SVparam.Specs.length;
	Menu_unSelectAll();
}

function Menu_MakeselectSpectrum(oEvent,id){
	var i, id1;

	//alert("MakeSelection: "+id);
	if (oEvent.shiftKey){
		// Multi-select with mouse button and Shift key 
		if(SVparam.Specs.length>0){
			// Call Menu_selectSpectrum multiple times
			id1=SVparam.Specs[SVparam.Specs.length-1];
			if(id1>id){
				for(i=id; i<id1; i++) Menu_selectSpectrum(i);
			} else {
				for(i=id1+1; i<=id; i++){ Menu_selectSpectrum(i); }
			}
		} else {
			// Even though shift key is used, this is the first spectrum so just select it
			Menu_selectSpectrum(id);
		}
	} else {
		// Single-select with mouse button only
		Menu_selectSpectrum(id);
	}
}

function Menu_selectSpectrum(id){
	var iframe, iframeDoc, j, rowID;

	document.getElementById("displayMistake").innerHTML="";

	// Check for duplicates
	j=0;
	if(SVparam.DisplayedSpecs.length>0){
		while(j<SVparam.DisplayedSpecs.length){
			if(SVparam.DisplayedSpecs[j]!=id) j++;
			else {
				SVparam.word='Spectrum "'+SVparam.spectrum_names[id]+'" already displayed, use "Clear Spectra"';
				document.getElementById("displayMistake").innerHTML=SVparam.word;
				return;
			}
		}
	}
	j=0;
	if(SVparam.Specs.length>0){
		while(j<SVparam.Specs.length){
			if(SVparam.Specs[j]!=id) j++;
			else{
				return;
			}
		}
	}

	// Connect to the iframe and make the changes to the selected row
	iframe = document.getElementById('menu_iframe');
	iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
	rowID = iframeDoc.getElementById("row"+id);
	iframeDoc.getElementById("row"+id).setAttribute('background-color', "lightblue");
	iframeDoc.getElementById("row"+id).setAttribute('onclick', 'parent.Menu_unselectSpectrum('+id+')');

	// Add this spectrum to the Specs list
	SVparam.Specs[SVparam.Specs.length]=id;
}

function List_update(id,colorID) {
	var i, table, row;

	table = document.getElementById("recent_list");
	//don't duplicate things in the list:
	for(i=0; i<table.getElementsByTagName("tr").length; i++){
		if(table.getElementsByTagName('tr')[i].innerHTML.indexOf(SVparam.spectrum_names[id]) != -1)
			table.deleteRow(i);
	}

	SVparam.word='<td width="25px" align="center" id="box'+colorID+'" style="display:inline-block;width:20px;background-color:'+SVparam.dataColor[colorID]+';color:'+SVparam.dataColor[colorID]+'">:-)</td><td width="150px" align="center"><button type="button" class="navLink" value="Display" onclick="displaySpectrum('+id+')">Display</button>'+' <button type="button" class="navLink" value="Overlay" onclick="overlaySpectrum('+id+')">Overlay</button></td><td width="225px">'+SVparam.spectrum_names[id]+' </td><td id="spec_fits'+colorID+'"></td>';
	table.setAttribute('style', 'display:block; margin-top:10px;')
	row = table.insertRow(0);
	row.innerHTML =SVparam.word;

	i = table.getElementsByTagName("tr").length;
	if(i>40) table.deleteRow(i-1);
}

function reset_list_color(){
	var j, x;

	for(j=0; j<10; j++){
		x=document.getElementById("box"+j);
		if(x){
			x.setAttribute('style', "background-color:#333333;color:#333333");
			x.setAttribute('id', "");
		}
	}
}

function displaySpectrum(id){
	var j;

	document.getElementById("displayMistake").innerHTML="";

	SVparam.XaxisLimitAbsMax=500;
	SVparam.YaxisLimitMax=5;
	reset_list_color();
	Menu_unSelectAll();
	SVparam.Specs[0]=id;
	List_update(id,0);

	SVparam.DisplayedSpecs=SVparam.Specs.slice();
	SVparam.NumSpecsDisplayed=1;
	plot_data(0);
}

function overlaySpectrum(id){
	var j, x;

	document.getElementById("displayMistake").innerHTML="";

	// Check for duplicates
	j=0;
	if(SVparam.DisplayedSpecs.length>0){
		while(j<SVparam.DisplayedSpecs.length){
			if(SVparam.DisplayedSpecs[j]!=id) j++;
			else {
				SVparam.word='Spectrum "'+SVparam.spectrum_names[id]+'" already displayed';
				document.getElementById("displayMistake").innerHTML=SVparam.word;
				return;
			}
		}
	}

	// Add this spectrum to the Specs list
	//SVparam.Specs[SVparam.Specs.length]=id;
	SVparam.Specs = [id]  //dubious hack seems to fix the funky behavior of the above line - first use of overlay duplicated the original spectrum, investigate.

	//Check number of displayed spectra
	if((SVparam.Specs.length+SVparam.NumSpecsDisplayed)>10){
		document.getElementById("displayMistake").innerHTML="Maximum of 10 spectra can be overlayed";
		return;
	}

	// Plot the spectra
	for(j=0; j<SVparam.Specs.length; j++){
		SVparam.DisplayedSpecs[SVparam.DisplayedSpecs.length]=SVparam.Specs[j];
		List_update(SVparam.Specs[j],SVparam.NumSpecsDisplayed+j);
	}
	plot_data(0);

	SVparam.NumSpecsDisplayed=SVparam.NumSpecsDisplayed+SVparam.Specs.length;
	Menu_unSelectAll();
}

function Menu_unselectSpectrum(id){
	var iframe, iframeDoc, j, k;

	document.getElementById("displayMistake").innerHTML="";
	iframe = document.getElementById('menu_iframe');
	iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
	iframeDoc.getElementById("row"+id).setAttribute('background-color', "#333333");
	iframeDoc.getElementById("row"+id).setAttribute('onclick', "parent.Menu_selectSpectrum("+id+")");

	// Remove this spectrum from the parent.Spec array
	j=0;
	if(SVparam.Specs.length>0){
		while(SVparam.Specs[j]!=id){
			j++;
		}
		k=j+1;
		while(k<SVparam.Specs.length){
			SVparam.Specs[j]=SVparam.Specs[k];
			j++; 
			k++;
		}
	}
	SVparam.Specs=SVparam.Specs.slice(0,j);
}

function clearSpecs(){

	//1D:
	if(document.getElementById('LowerXLimit')){
		reset_list_color();
		SVparam.Specs=[];

		SVparam.DisplayedSpecs=SVparam.Specs.slice();
		SVparam.NumSpecsDisplayed=0;

		drawFrame();
	}
	//2D:
	if(document.getElementById('LowerXLimit2D')){
		draw2Dframe();
	}

}

function getSpecData(x, abandonBuffer){
	if(!SVparam.devMode){
		if(SVparam.dataBuffer[parseInt(x)] && !abandonBuffer){
			return SVparam.dataBuffer[parseInt(x)];
		} else {
			SVparam.dataBuffer[parseInt(x)] = getData(parseInt(x));
			return SVparam.dataBuffer[parseInt(x)];
		}
	} else {
		if(x==0) return SVfakeData.energydata0;
		if(x==1) return SVfakeData.energydata1;
		if(x==2) return SVfakeData.energydata2;
		if(x==3) return SVfakeData.energydata3;
		if(x==4) return SVfakeData.energydata4;
	}
}

function relMouseCoords(event){
    var totalOffsetX = 0,
    totalOffsetY = 0,
    canvasX = 0,
    canvasY = 0,
    currentElement = this,
    test = [],
    elts = [];

	if (event.offsetX !== undefined && event.offsetY !== undefined) { return {x:event.offsetX, y:event.offsetY}; }
	//if (event.layerX !== undefined && event.layerY !== undefined) { return {x:event.layerX, y:event.layerY}; }

    do{
        totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
        totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
        //test[test.length] = currentElement.offsetLeft - currentElement.scrollLeft
        //elts[elts.length] = currentElement
    }
    while(currentElement = currentElement.offsetParent)

    canvasX = event.pageX - totalOffsetX;
    canvasY = event.pageY - totalOffsetY;

    //hack to deal with FF scroll, better solution TBD:
    if(event.offsetX == undefined){
    	canvasX -= document.body.scrollLeft;
    	canvasY -= document.body.scrollTop;
    }

    return {x:canvasX, y:canvasY}
}
HTMLCanvasElement.prototype.relMouseCoords = relMouseCoords;

//call <target==1,2>D view to display in Spectrum Control panel
function summonView(target){
	if(target==1){
		document.getElementById('spectrumBlock2D').setAttribute('style', 'display:none;');
		document.getElementById('spectrumBlock1D').setAttribute('style', '');
		document.getElementById('overlayB').setAttribute('style', '');
	} else if(target==2){
		document.getElementById('spectrumBlock1D').setAttribute('style', 'display:none;');
		document.getElementById('spectrumBlock2D').setAttribute('style', '');
		document.getElementById('spectrumBlock2D').setAttribute('width', '100%');
		document.getElementById('overlayB').setAttribute('style', 'display:none');
	}
}


//stuff for 2D mode///////////////////////////////////////////////////////////////////////////////////
//draw the frame for the 2D view:
function draw2Dframe(){
	var binsPerTick, i, label;

	//determine bin render width
	SVparam.binWidth2D  = SVparam.xAxisPixLength2D / (SVparam.XaxisLimitMax2D - SVparam.XaxisLimitMin2D);
	SVparam.binHeight2D = SVparam.yAxisPixLength2D / (SVparam.YaxisLimitMax2D - SVparam.YaxisLimitMin2D);

	//clear canvas
	SVparam.context2D.clearRect(0,0,SVparam.canvWidth2D, SVparam.canvHeight2D);

	//draw principle axes:
	SVparam.context2D.strokeStyle = '#FFFFFF';
	SVparam.context2D.fillStyle = '#FFFFFF';
	SVparam.context2D.lineWidth = 1;
	SVparam.context2D.beginPath();
	SVparam.context2D.moveTo(SVparam.leftMargin2D, SVparam.topMargin2D);
	SVparam.context2D.lineTo(SVparam.leftMargin2D, SVparam.canvas2D.height-SVparam.bottomMargin2D);
	SVparam.context2D.lineTo(SVparam.canvas2D.width - SVparam.rightMargin2D - SVparam.zScaleMargin, SVparam.canvas2D.height - SVparam.bottomMargin2D);
	SVparam.context2D.stroke();

	//Decorate x axis////////////////////////////////////////////////////////
	//decide how many ticks to draw on the x axis:
	SVparam.nXticks = 6;
	//draw at most one tick per bin:
	if(SVparam.XaxisLength2D < (SVparam.nXticks-1) )
		SVparam.nXticks = SVparam.XaxisLength2D+1
	//come as close to a factor of the number of bins as possible:
	while( Math.floor(SVparam.XaxisLength2D / SVparam.nXticks) == Math.floor(SVparam.XaxisLength2D / (SVparam.nXticks-1)) )
		SVparam.nXticks--;

	//how many bins should there be between each tick?
	binsPerTick = Math.floor((SVparam.XaxisLimitMax2D - SVparam.XaxisLimitMin2D) / (SVparam.nXticks-1));

	//draw x axis ticks & labels:
	for(i=0; i<SVparam.nXticks; i++){
		//ticks
		SVparam.context2D.beginPath();
		SVparam.context2D.moveTo(SVparam.leftMargin2D + i*binsPerTick*SVparam.binWidth2D, SVparam.canvas2D.height - SVparam.bottomMargin2D);
		SVparam.context2D.lineTo(SVparam.leftMargin2D + i*binsPerTick*SVparam.binWidth2D, SVparam.canvas2D.height - SVparam.bottomMargin2D + SVparam.tickLength);
		SVparam.context2D.stroke();

		//labels
		label = (SVparam.XaxisLimitMin2D + i*binsPerTick).toFixed(0);
		SVparam.context2D.textBaseline = 'top';
		SVparam.context2D.fillText(label, SVparam.leftMargin2D + i*binsPerTick*SVparam.binWidth2D - SVparam.context2D.measureText(label).width/2, SVparam.canvas2D.height - SVparam.bottomMargin2D + SVparam.tickLength + SVparam.xLabelOffset);
	}

	//Decorate Y axis/////////////////////////////////////////////////////////
	//decide how many ticks to draw on the y axis:
	SVparam.nYticks = 6;
	//come as close to a factor of the number of bins as possible:
	while( Math.floor(SVparam.YaxisLength2D / SVparam.nYticks) == Math.floor(SVparam.YaxisLength2D / (SVparam.nYticks-1)) )
		SVparam.nYticks--;

	//how many bins should each tick increment?
	binsPerTick = Math.floor(SVparam.YaxisLength2D / (SVparam.nYticks-1));

	//draw y axis ticks and labels:
	for(i=0; i<SVparam.nYticks; i++){
		//ticks
		SVparam.context2D.beginPath();
		SVparam.context2D.moveTo(SVparam.leftMargin2D, SVparam.canvas2D.height - SVparam.bottomMargin2D - i*binsPerTick*SVparam.binHeight2D);
		SVparam.context2D.lineTo(SVparam.leftMargin2D - SVparam.tickLength, SVparam.canvas2D.height - SVparam.bottomMargin2D - i*binsPerTick*SVparam.binHeight2D);
		SVparam.context2D.stroke();

		//labels
		SVparam.context2D.textBaseline = 'middle';
		label = (SVparam.YaxisLimitMin2D + i*binsPerTick).toFixed(0);
		SVparam.context2D.fillText(label, SVparam.leftMargin2D - SVparam.tickLength - SVparam.yLabelOffset - SVparam.context2D.measureText(label).width, SVparam.canvas2D.height - SVparam.bottomMargin2D - i*binsPerTick*SVparam.binHeight2D);

	}

	//x axis title:
	SVparam.context2D.textBaseline = 'bottom';
	SVparam.context2D.fillText('Total E', SVparam.canvas2D.width - SVparam.rightMargin2D - SVparam.context2D.measureText('Total E').width - SVparam.zScaleMargin, SVparam.canvas2D.height);

	//y axis title:
	SVparam.context2D.textBaseline = 'alphabetic';
	SVparam.context2D.save();
	SVparam.context2D.translate(SVparam.leftMargin2D*0.25, SVparam.context2D.measureText('dE').width + SVparam.topMargin2D );
	SVparam.context2D.rotate(-Math.PI/2);
	SVparam.context2D.fillText('dE', 0,0);
	SVparam.context2D.restore();

}

function plot_data2D(RefreshNow, abandonBuffer){
	var i, j, data, thisSpec, 
	entries = 0,
	thisData = [];
	SVparam.entries = [];

	SVparam.context2D.font = (16*window.innerWidth/1440)+'px Raleway';

	//echo back the axis limits in the input textboxes:
	document.getElementById('LowerXLimit2D').value = SVparam.XaxisLimitMin2D;
	document.getElementById('UpperXLimit2D').value = SVparam.XaxisLimitMax2D;
	document.getElementById('LowerYLimit').value = SVparam.YaxisLimitMin2D;
	document.getElementById('UpperYLimit').value = SVparam.YaxisLimitMax2D;

	if(abandonBuffer){
		thisData = getData2D(0).split(';');
		for(i=0; i<thisData.length; i++){
			thisData[i] = thisData[i].split(',');
			thisData[i] = {'x' : parseInt(thisData[i][0]), 'y' : parseInt(thisData[i][1]), 'z' : parseInt(thisData[i][2])}
		}
		SVparam.dataBuffer2D = thisData;
	} else {
		thisData = SVparam.dataBuffer2D;
	}
/*
	SVparam.maxYvalue=SVparam.YaxisLimitMax;
	// Loop through to get the data and set the Y axis limits
	for(thisSpec=0; thisSpec<SVparam.DisplayedSpecs.length; thisSpec++){
		// Here call function to get data from the server
		// thisData[thisSpec]=ODBGet("/Test/spectrum_data[*]","%d");
		thisData[thisSpec]=getSpecData(SVparam.DisplayedSpecs[thisSpec], abandonBuffer);

		//Find the maximum X value from the size of the data
		if(thisData[thisSpec].length>SVparam.XaxisLimitAbsMax){
			SVparam.XaxisLimitAbsMax=thisData[thisSpec].length;

			// Create more datapoints here if required for this spectrum
		}

		// Find maximum Y value in the part of the spectrum to be displayed
		if(Math.max.apply(Math, thisData[thisSpec].slice(Math.floor(SVparam.XaxisLimitMin),Math.floor(SVparam.XaxisLimitMax)))>SVparam.maxYvalue){
			SVparam.maxYvalue=Math.max.apply(Math, thisData[thisSpec].slice(Math.floor(SVparam.XaxisLimitMin),Math.floor(SVparam.XaxisLimitMax)));
		}

		// Find the sum of everything in the current x range
		data = thisData[thisSpec].slice(  Math.floor(SVparam.XaxisLimitMin),Math.floor(SVparam.XaxisLimitMax)   );
		SVparam.totalEntries = 0;
		for(j=0; j<data.length; j++ ){
			SVparam.totalEntries += data[j];
		}

		//report number of entries on canvas:
		SVparam.entries[thisSpec] = SVparam.totalEntries;

	}// End of for loop
*/
/*
	// Adjust the Y axis limit and compression and redraw the axis
	if(SVparam.maxYvalue>5){
		if(SVparam.AxisType==0) SVparam.YaxisLimitMax=Math.floor(SVparam.maxYvalue*1);
		if(SVparam.AxisType==1) SVparam.YaxisLimitMax=SVparam.maxYvalue*10;
	} else {
		if(SVparam.AxisType==0) SVparam.YaxisLimitMax=5;
		if(SVparam.AxisType==1) SVparam.YaxisLimitMax=50;
	}
*/
	//update axis range
	SVparam.XaxisLength2D=SVparam.XaxisLimitMax2D-SVparam.XaxisLimitMin2D;
	SVparam.YaxisLength2D=SVparam.YaxisLimitMax2D-SVparam.YaxisLimitMin2D;

	draw2Dframe();

	//determine the maximum z value:
	for(i=0; i<thisData.length; i++){
		if(!SVparam.logZ)
			SVparam.zMax = Math.max(SVparam.zMax, thisData[i].z);
		else 
			SVparam.zMax = Math.max(SVparam.zMax, Math.log10(thisData[i].z));
	}
	if(!SVparam.zMax)
		SVparam.zMax = 1;

	//fill in all the unpopulated bins:
	SVparam.context2D.fillStyle = scalepickr('unpopulated', 'ROOT Rainbow');
	SVparam.context2D.fillRect(SVparam.leftMargin2D, SVparam.canvHeight2D - SVparam.bottomMargin2D - SVparam.yAxisPixLength2D, SVparam.xAxisPixLength2D, SVparam.yAxisPixLength2D)

	//fill histo:
	for(i=0; i<thisData.length; i++){
		if(thisData[i].x >= SVparam.XaxisLimitMin2D && thisData[i].x < SVparam.XaxisLimitMax2D && thisData[i].y >= SVparam.YaxisLimitMin2D && thisData[i].y < SVparam.YaxisLimitMax2D){
			if(!SVparam.logZ)
				SVparam.context2D.fillStyle = scalepickr(thisData[i].z / SVparam.zMax, 'ROOT Rainbow');
			else
				SVparam.context2D.fillStyle = scalepickr( (Math.log10(thisData[i].z) - SVparam.logZmin ) / (SVparam.zMax - SVparam.logZmin ), 'ROOT Rainbow');

			//SVparam.context2D.shadowColor = scalepickr(thisData[i].z, 'ROOT Rainbow');
			SVparam.context2D.fillRect(SVparam.leftMargin2D + (thisData[i].x-SVparam.XaxisLimitMin2D)*SVparam.binWidth2D, SVparam.canvas2D.height - SVparam.bottomMargin2D - (thisData[i].y-SVparam.YaxisLimitMin2D+1)*SVparam.binHeight2D ,SVparam.binWidth2D,SVparam.binHeight2D);
			entries += thisData[i].z;
		}
	}

	//report entries:
	SVparam.context2D.textBaseline = 'top';
	SVparam.context2D.fillStyle = '#999999';
	SVparam.context2D.fillText('Entries: '+entries, SVparam.canvas2D.width - SVparam.rightMargin2D - SVparam.context2D.measureText('Entries: '+entries).width - SVparam.zScaleMargin, 16);

	//overlay tbragg gates if running on tbragg:
	drawTbraggGates();

	//draw scale
	drawZscale();

	// Pause for some time and then recall this function to refresh the data display
	if(SVparam.RefreshTime>0 && RefreshNow==1)  SVparam.refreshHandler2D = setTimeout(function(){plot_data2D(1, 'true')},SVparam.RefreshTime*1000); 
}

//mouse down & mouse up behavior functions for 2D canvas:
function mDown2D(event){
	var x, y, xBin, yBin, coords;

	//prevent defaults from messing with the drag:
	event.preventDefault();

	//draggy hand:
	SVparam.activeCursor = 1;

	coords = document.getElementById(SVparam.canvasID2D).relMouseCoords(event);
	x = coords.x;
	y = coords.y;

	xBin = Math.floor((x-SVparam.leftMargin2D)/SVparam.binWidth2D + SVparam.XaxisLimitMin2D);
	yBin = Math.floor((SVparam.canvas2D.height-SVparam.bottomMargin2D - y)/SVparam.binHeight2D + SVparam.YaxisLimitMin2D);
	//if(xBin < 0) xBin = 0;
	//if(yBin < 0) yBin = 0;
	if(xBin < SVparam.XaxisLimitMin2D) xBin = SVparam.XaxisLimitMin2D;
	if(yBin < SVparam.YaxisLimitMin2D) yBin = SVparam.YaxisLimitMin2D;
	if(xBin > SVparam.XaxisLimitMax2D) xBin = SVparam.XaxisLimitMax2D;
	if(yBin > SVparam.YaxisLimitMax2D) yBin = SVparam.YaxisLimitMax2D;

	//drag a box if clicking in the plot field:
	if(x > SVparam.leftMargin2D && x < (SVparam.canvas2D.width - SVparam.rightMargin2D) && y>SVparam.topMargin2D && y<(SVparam.canvas2D.height-SVparam.bottomMargin2D)){
		SVparam.onclickXvals.min = xBin;
		SVparam.onclickYvals.min = yBin;
	} else if(y > (SVparam.canvas2D.height-SVparam.bottomMargin2D) && SVparam.clickX.down == -1 && SVparam.clickY.down == -1){ //clicking in the x-margin
		SVparam.clickX['down'] = xBin;
		//deal with the possibility that the user clicked on the ambiguous region in the bottom left corner and actually wanted the y-margin:
		if(x < SVparam.leftMargin2D)
			SVparam.clickY['down'] = yBin
	} else if (x < SVparam.leftMargin2D && SVparam.clickY.down == -1){  //user clicked in the y-margin
		SVparam.clickY['down'] = yBin;
	}
}

function mUp2D(event){
	var x, y, xBin, yBin, coords;

	//release draggy hand:
	SVparam.activeCursor = 0;

	coords = document.getElementById(SVparam.canvasID2D).relMouseCoords(event);
	x = coords.x;
	y = coords.y;

	xBin = Math.floor((x-SVparam.leftMargin2D)/SVparam.binWidth2D + SVparam.XaxisLimitMin2D);
	yBin = Math.floor((SVparam.canvas2D.height-SVparam.bottomMargin2D - y)/SVparam.binHeight2D + SVparam.YaxisLimitMin2D);
	if(xBin < SVparam.XaxisLimitMin2D) xBin = SVparam.XaxisLimitMin2D;
	if(yBin < SVparam.YaxisLimitMin2D) yBin = SVparam.YaxisLimitMin2D;
	if(xBin > SVparam.XaxisLimitMax2D) xBin = SVparam.XaxisLimitMax2D;
	if(yBin > SVparam.YaxisLimitMax2D) yBin = SVparam.YaxisLimitMax2D;

	//bail out on a single click:
	if( (xBin == SVparam.onclickXvals.min && yBin == SVparam.onclickYvals.min) || (xBin == SVparam.clickX['down'] && yBin == SVparam.clickY['down']) ){
		SVparam.onclickXvals = {'min':-1, 'max':-1};
		SVparam.onclickYvals = {'min':-1, 'max':-1};
		SVparam.clickX = {'down':-1, 'up':-1};
		SVparam.clickY = {'down':-1, 'up':-1};
		return;
	}

	if(SVparam.onclickXvals.min != -1){
		SVparam.onclickXvals.max = xBin;
		SVparam.onclickYvals.max = yBin;

		//make sure the mins and maxes go to the right place, in case the user dragged backwards:
		SVparam.XaxisLimitMin2D = Math.min(SVparam.onclickXvals.min, SVparam.onclickXvals.max);
		SVparam.XaxisLimitMax2D = Math.max(SVparam.onclickXvals.min, SVparam.onclickXvals.max);
		SVparam.YaxisLimitMin2D = Math.min(SVparam.onclickYvals.min, SVparam.onclickYvals.max);
		SVparam.YaxisLimitMax2D = Math.max(SVparam.onclickYvals.min, SVparam.onclickYvals.max);

		//redraw with new bounds:
		plot_data2D();
		SVparam.onclickXvals = {'min':-1, 'max':-1};
		SVparam.onclickYvals = {'min':-1, 'max':-1};
		return;

	} else if (y > (SVparam.canvas2D.height-SVparam.bottomMargin2D) && x > SVparam.leftMargin2D){ //release on the x-margin
		SVparam.clickX['up'] = xBin;
	} else if (x < SVparam.leftMargin2D && y < (SVparam.canvas2D.height-SVparam.bottomMargin2D)){ //release on the y-margin
		SVparam.clickY['up'] = yBin;
	} else if (x < SVparam.leftMargin2D && y > (SVparam.canvas2D.height-SVparam.bottomMargin2D)){ //release on the margin overlap
		SVparam.clickX['up'] = xBin;
		SVparam.clickY['up'] = yBin;
	}

	//valid X range found:
	if(SVparam.clickX.up != SVparam.clickX.down && SVparam.clickX.up>=0 && SVparam.clickX.down>=0){
		SVparam.XaxisLimitMin2D = Math.min(SVparam.clickX.up, SVparam.clickX.down);
		SVparam.XaxisLimitMax2D = Math.max(SVparam.clickX.up, SVparam.clickX.down);
		plot_data2D();
		SVparam.clickX.up = -1;
		SVparam.clickX.down = -1;
	} else if(SVparam.clickY.up != SVparam.clickY.down && SVparam.clickY.up>=0 && SVparam.clickY.down>=0){ //valid Y range found:
		SVparam.YaxisLimitMin2D = Math.min(SVparam.clickY.up, SVparam.clickY.down);
		SVparam.YaxisLimitMax2D = Math.max(SVparam.clickY.up, SVparam.clickY.down);
		plot_data2D();
		SVparam.clickY.up = -1;
		SVparam.clickY.down = -1;
	}
}

function mMove2D(event){
	var x, y, coords, xBin, yBin;

	if(SVparam.activeCursor)
		document.body.style.cursor = 'nwse-resize';
	else
		document.body.style.cursor = 'default'; 

	coords = document.getElementById(SVparam.canvasID2D).relMouseCoords(event);
	x = coords.x;
	y = coords.y;

	xBin = Math.floor((x-SVparam.leftMargin2D)/SVparam.binWidth2D+SVparam.XaxisLimitMin2D);
	yBin = Math.floor((SVparam.canvas2D.height-SVparam.bottomMargin2D-y)/SVparam.binHeight2D+SVparam.YaxisLimitMin2D);

	document.getElementById('2Dcoords').innerHTML = 'x: '+xBin+', y: '+yBin;

}

//draw a zaxis scale for the 2D plot:
function drawZscale(){
	var i, x0, y0, 
	width = SVparam.yAxisPixLength2D*0.08;
	length = SVparam.yAxisPixLength2D*0.9

	//top corner of scale:
	x0 = SVparam.leftMargin2D + SVparam.xAxisPixLength2D + SVparam.rightMargin2D;
	y0 = SVparam.topMargin2D;

	//color bar
	for(i=0; i<1000; i++){
		SVparam.context2D.fillStyle = scalepickr(i/1000, 'ROOT Rainbow');
		SVparam.context2D.fillRect(x0, SVparam.canvHeight2D - SVparam.bottomMargin2D - (SVparam.yAxisPixLength2D - length) - (i+1)*length/1000, width, length/1000);
	}

	//frame
	SVparam.context2D.strokeStyle = '#FFFFFF';
	SVparam.context2D.lineWidth = 1;
	SVparam.context2D.beginPath();
	SVparam.context2D.moveTo(x0+width, y0);
	SVparam.context2D.lineTo(x0+width, y0+length);
	SVparam.context2D.stroke();
	SVparam.context2D.closePath();
	for(i=0; i<5; i++){
		//ticks
		SVparam.context2D.beginPath();
		SVparam.context2D.moveTo(x0+width, SVparam.canvHeight2D - SVparam.bottomMargin2D - (SVparam.yAxisPixLength2D - length) - i*length/4);
		SVparam.context2D.lineTo(x0+width+SVparam.tickLength, SVparam.canvHeight2D - SVparam.bottomMargin2D - (SVparam.yAxisPixLength2D - length) - i*length/4);
		SVparam.context2D.stroke();
		SVparam.context2D.closePath();

		//labels
		SVparam.context2D.textBaseline = 'middle';
		SVparam.context2D.fillStyle = '#FFFFFF';
		if(!SVparam.logZ)
			label = (i*SVparam.zMax/4).toFixed(1);
		else
			label = (SVparam.logZmin + i/4*(SVparam.zMax - SVparam.logZmin)).toFixed(1);
		SVparam.context2D.fillText(label, x0+width+SVparam.tickLength + 5, SVparam.canvHeight2D - SVparam.bottomMargin2D - (SVparam.yAxisPixLength2D - length) - i*length/4)
	}
	SVparam.context2D.textBaseline = 'alphabetic';

	//title
	SVparam.context2D.save();
	SVparam.context2D.font = (20*window.innerWidth/1440)+'px Raleway'
	SVparam.context2D.translate(x0 + 2*width, y0 + SVparam.yAxisPixLength2D/2 - SVparam.context2D.measureText('log(counts)').width/2)
	SVparam.context2D.rotate(Math.PI/2);
	SVparam.context2D.fillText('log ( counts )', 0,0);
	SVparam.context2D.restore();

	//legend:
	SVparam.context2D.fillRect(x0, y0+SVparam.yAxisPixLength2D-width, width, width);
	SVparam.context2D.strokeStyle = '#000000'
	SVparam.context2D.lineWidth = 2;
	SVparam.context2D.textBaseline = 'middle';
	SVparam.context2D.strokeRect(x0, y0+SVparam.yAxisPixLength2D-width, width, width);
	SVparam.context2D.fillText('Absent', x0+width+5, y0+SVparam.yAxisPixLength2D-width/2)

}

//Draw the gate boxes for use with the TBRAGG viewer:
function drawTbraggGates(){
	var i, x0, y0, size, height, width;

	if(document.getElementById('GateSize0')){
		for(i=0; i<TBparam.num_gates+1; i++){

			//in bins
			size = parseInt(document.getElementById('GateSize'+i).value);
			x0 = parseInt(document.getElementById('Gatex'+i).value) - size/2;
			y0 = parseInt(document.getElementById('Gatey'+i).value) + size/2;

			//in pixels
			height = size*SVparam.binHeight2D;
			width = size*SVparam.binWidth2D;
			x0 = SVparam.leftMargin2D + (x0 - SVparam.XaxisLimitMin2D)*SVparam.binWidth2D;
			y0 = SVparam.canvHeight2D - SVparam.bottomMargin2D - (y0 - SVparam.YaxisLimitMin2D)*SVparam.binHeight2D;

			//don't let the boxes go over the edge:
			//RHS:
			if(x0+width > SVparam.canvWidth2D-SVparam.rightMargin2D-SVparam.zScaleMargin && x0 < SVparam.canvWidth2D-SVparam.rightMargin2D-SVparam.zScaleMargin) 
				width = SVparam.canvWidth2D-SVparam.rightMargin2D-SVparam.zScaleMargin - x0;
			//LHS:
			if(x0 < SVparam.leftMargin2D && x0+width > SVparam.leftMargin2D){
				width -= SVparam.leftMargin2D - x0
				x0 = SVparam.leftMargin2D;
			} 
			//bottom:
			if(y0 + height > SVparam.canvHeight2D-SVparam.bottomMargin2D && y0 < SVparam.canvHeight2D-SVparam.bottomMargin2D) 
				height = SVparam.canvHeight2D-SVparam.bottomMargin2D - y0;
			//top:
			if(y0 < SVparam.topMargin2D && y0+height > SVparam.topMargin2D){
				height -= SVparam.topMargin2D - y0;
				y0 = SVparam.topMargin2D;
			}

			//draw
			if(x0+width > SVparam.leftMargin2D && x0 < SVparam.canvWidth2D-SVparam.rightMargin2D-SVparam.zScaleMargin && y0<SVparam.canvHeight2D-SVparam.bottomMargin2D && y0+height>SVparam.topMargin2D){
				SVparam.context2D.strokeStyle = TBparam.barChartColors[i+1];
				SVparam.context2D.lineWidth = 3;
				SVparam.context2D.strokeRect(x0,y0,width,height);
			}
		}
	}
}


//map [0,1] onto black->purple->red->orange->yellow->white
scalepickr = function(scale, palette){

    //map scale onto [0,360]:
    var H = scale*300 / 60;
    if(H>5) H=5;
    if(H<0) H=0;
    var R, G, B;
    var start0, start1, start2, start3, start4, start5;
    if (palette == 'Sunset'){
        start0 = [0,0,0];
        start1 = [0,0,0x52];
        start2 = [0xE6,0,0x5C];
        start3 = [255,255,0];        
        start4 = [255,0x66,0];
        start5 = [255,0,0];        
    } else if (palette == 'ROOT Rainbow'){

	 	//escape to white for unpopulated channels:
		if(scale=='unpopulated')
			return constructHexColor([255,255,255]);

        start0 = [0xFF,0x00,0x00];
        start1 = [0xFF,0xFF,0x00];
        start2 = [0x00,0xFF,0x00];
        start3 = [0x00,0xFF,0xFF];
        start4 = [0x00,0x00,0xFF];
        start5 = [0x66,0x00,0xCC];
        H = -1*(H-5);
    } else if (palette == 'Greyscale'){
        start0 = [0x00,0x00,0x00];
        start1 = [0x22,0x22,0x22];
        start2 = [0x55,0x55,0x55];
        start3 = [0x88,0x88,0x88];        
        start4 = [0xBB,0xBB,0xBB];
        start5 = [0xFF,0xFF,0xFF];
    } else if (palette == 'Red Scale'){
        start0 = [0x00,0x00,0x00];
        start1 = [0x33,0x00,0x00];
        start2 = [0x66,0x00,0x00];
        start3 = [0x99,0x00,0x00];
        start4 = [0xCC,0x00,0x00];
        start5 = [0xFF,0x00,0x00];
    } else if (palette == 'Mayfair'){
        start0 = [0x1E,0x4B,0x0F];
        start1 = [0x0E,0xBE,0x57];
        start2 = [0xE4,0xAB,0x33];
        start3 = [0xEC,0x95,0xF7];
        start4 = [0x86,0x19,0x4A];
        start5 = [0xFF,0x10,0x10];
    } else if (palette == 'Test'){
        start0 = [0x5E,0x1F,0x14];
        start1 = [0x74,0x4D,0x3E];
        start2 = [0x9D,0x47,0x05];
        start3 = [0xDF,0x67,0x19];
        start4 = [0xFE,0x83,0x54];
        start5 = [0x251,0x15,0x29];
    }
    if(H>=0 && H<1){
        R = start0[0] + Math.round(H*(start1[0]-start0[0]));
        G = start0[1] + Math.round(H*(start1[1]-start0[1]));
        B = start0[2] + Math.round(H*(start1[2]-start0[2]));
    } else if(H>=1 && H<2){
        R = start1[0] + Math.round((H-1)*(start2[0]-start1[0]));
        G = start1[1] + Math.round((H-1)*(start2[1]-start1[1]));
        B = start1[2] + Math.round((H-1)*(start2[2]-start1[2]));
    } else if(H>=2 && H<3){
        R = start2[0] + Math.round((H-2)*(start3[0]-start2[0]));
        G = start2[1] + Math.round((H-2)*(start3[1]-start2[1]));
        B = start2[2] + Math.round((H-2)*(start3[2]-start2[2]));
    } else if(H>=3 && H<4){
        R = start3[0] + Math.round((H-3)*(start4[0]-start3[0]));
        G = start3[1] + Math.round((H-3)*(start4[1]-start3[1]));
        B = start3[2] + Math.round((H-3)*(start4[2]-start3[2]));
    } else if(H>=4 && H<=5){
        R = start4[0] + Math.round((H-4)*(start5[0]-start4[0]));
        G = start4[1] + Math.round((H-4)*(start5[1]-start4[1]));
        B = start4[2] + Math.round((H-4)*(start5[2]-start4[2]));  
    }

    return constructHexColor([R,G,B]);

}

function constructHexColor(color){
    var R = Math.round(color[0]);
    var G = Math.round(color[1]);
    var B = Math.round(color[2]);

    R = R.toString(16);
    G = G.toString(16);
    B = B.toString(16);

    if(R.length == 1) R = '0'+R;
    if(G.length == 1) G = '0'+G;
    if(B.length == 1) B = '0'+B;

    return '#'+R+G+B;
}

// To do list:
// 
// General:
// - Reorder the specs list before displaying to handle mutliple selection better
// - include overlay functionality for points data OR REMOVE FUCNTIONALITY - removed for now
// - Reset function to make an array and subtract that from what we get from midas for zeroing spectra ie. spectrum not reset for all users
// - Comment entire code
//
// Cool extras:
// - data points get larger when zoomed in
// - Sleek buttons from images with mouseover effects
//
// 2D spectra:
// - Make a 2D menu load button
// - y axis zoomable with mouse and limit entry
// - 2D data array with each line as all y points of x
		</script>

	</body>
</html>